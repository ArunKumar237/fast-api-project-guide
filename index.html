<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>FastAPI Marketplace API ‚Äî Learning Reference</title>
		<meta name="description" content="Comprehensive learning reference for building a Multi-Vendor E-Commerce Marketplace API with FastAPI."/>
		<link rel="preconnect" href="https://fonts.googleapis.com"/>
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet"/>
		<link rel="stylesheet" href="styles.min.css"/>
	</head>
	<body>
		<!-- ==================== PROGRESS BAR ==================== -->
		<div id="progress-bar" class="progress-bar">
			<div id="progress-fill" class="progress-fill"></div>
		</div>
		<!-- ==================== MOBILE MENU TOGGLE ==================== -->
		<button id="menu-toggle" class="menu-toggle" aria-label="Toggle navigation menu">
			<span></span>
			<span></span>
			<span></span>
		</button>
		<!-- ==================== SIDEBAR NAVIGATION ==================== -->
		<aside id="sidebar" class="sidebar">
			<div class="sidebar-header">
				<h2 class="sidebar-title">üõí FastAPI<br/>Marketplace</h2>
				<span class="sidebar-subtitle">Learning Reference</span>
			</div>
			<div class="sidebar-search">
				<button id="search-btn" class="search-trigger" aria-label="Open search">
        üîç <span>Search topics‚Ä¶</span>
				</button>
			</div>
			<nav class="sidebar-nav" aria-label="Main navigation">
				<ul>
					<li>
						<a href="#section-1" class="nav-link active" data-section="section-1">
							<span class="nav-icon">üìã</span> Project Overview
          </a>
					</li>
					<li>
						<a href="#section-2" class="nav-link" data-section="section-2">
							<span class="nav-icon">üèóÔ∏è</span> Architecture &amp; Design
          </a>
					</li>
					<li>
						<a href="#section-3" class="nav-link" data-section="section-3">
							<span class="nav-icon">üóÑÔ∏è</span> Database Schema
          </a>
					</li>
					<li>
						<a href="#section-4" class="nav-link" data-section="section-4">
							<span class="nav-icon">üîå</span> API Endpoints
          </a>
					</li>
					<li class="nav-group">
						<button class="nav-group-toggle" aria-expanded="true" data-target="phases-nav">
							<span class="nav-icon">üöÄ</span> Implementation Phases
            <span class="toggle-icon">‚ñæ</span>
						</button>
						<ul id="phases-nav" class="nav-sub">
							<li>
								<a href="#phase-1" class="nav-link" data-section="phase-1">Phase 1: Project Setup</a>
							</li>
							<li>
								<a href="#phase-2" class="nav-link" data-section="phase-2">Phase 2: Auth ‚Äî Register &amp; Login</a>
							</li>
							<li>
								<a href="#phase-3" class="nav-link" data-section="phase-3">Phase 3: Role-Based Access</a>
							</li>
							<li>
								<a href="#phase-4" class="nav-link" data-section="phase-4">Phase 4: Store Management</a>
							</li>
							<li>
								<a href="#phase-5" class="nav-link" data-section="phase-5">Phase 5: Categories</a>
							</li>
							<li>
								<a href="#phase-6" class="nav-link" data-section="phase-6">Phase 6: Products</a>
							</li>
							<li>
								<a href="#phase-7" class="nav-link" data-section="phase-7">Phase 7: File Uploads</a>
							</li>
							<li>
								<a href="#phase-8" class="nav-link" data-section="phase-8">Phase 8: Shopping Cart</a>
							</li>
							<li>
								<a href="#phase-9" class="nav-link" data-section="phase-9">Phase 9: Orders</a>
							</li>
							<li>
								<a href="#phase-10" class="nav-link" data-section="phase-10">Phase 10: Reviews</a>
							</li>
							<li>
								<a href="#phase-11" class="nav-link" data-section="phase-11">Phase 11: Addresses</a>
							</li>
							<li>
								<a href="#phase-12" class="nav-link" data-section="phase-12">Phase 12: Background Tasks</a>
							</li>
							<li>
								<a href="#phase-13" class="nav-link" data-section="phase-13">Phase 13: Redis Caching</a>
							</li>
							<li>
								<a href="#phase-14" class="nav-link" data-section="phase-14">Phase 14: WebSockets</a>
							</li>
							<li>
								<a href="#phase-15" class="nav-link" data-section="phase-15">Phase 15: Middleware</a>
							</li>
							<li>
								<a href="#phase-16" class="nav-link" data-section="phase-16">Phase 16: Testing</a>
							</li>
							<li>
								<a href="#phase-17" class="nav-link" data-section="phase-17">Phase 17: Docker &amp; Deploy</a>
							</li>
						</ul>
					</li>
					<li>
						<a href="#section-6" class="nav-link" data-section="section-6">
							<span class="nav-icon">üìÅ</span> Project Structure
          </a>
					</li>
					<li>
						<a href="#section-7" class="nav-link" data-section="section-7">
							<span class="nav-icon">üîß</span> Dev Workflow
          </a>
					</li>
					<li>
						<a href="#section-8" class="nav-link" data-section="section-8">
							<span class="nav-icon">üîí</span> Security Basics
          </a>
					</li>
					<li>
						<a href="#section-9" class="nav-link" data-section="section-9">
							<span class="nav-icon">‚ö°</span> Performance Basics
          </a>
					</li>
					<li>
						<a href="#section-10" class="nav-link" data-section="section-10">
							<span class="nav-icon">üê≥</span> Deployment Basics
          </a>
					</li>
				</ul>
			</nav>
		</aside>
		<!-- ==================== SEARCH MODAL ==================== -->
		<div id="search-modal" class="search-modal" role="dialog" aria-label="Search" hidden>
		<div class="search-modal-backdrop"></div>
		<div class="search-modal-content">
			<div class="search-input-wrap">
				<span class="search-icon">üîç</span>
				<input type="text" id="search-input" class="search-input" placeholder="Search topics, phases, concepts‚Ä¶" autocomplete="off"/>
				<kbd class="search-kbd">ESC</kbd>
			</div>
			<div id="search-results" class="search-results">
				<p class="search-hint">Start typing to search across all sections‚Ä¶</p>
			</div>
		</div>
	</div>
	<!-- ==================== MAIN CONTENT ==================== -->
	<main id="main-content" class="main-content">
		<!-- ======================== HERO ======================== -->
		<header class="hero">
			<div class="hero-badge">üìò Learning Reference Document</div>
			<h1 class="hero-title">Multi-Vendor E-Commerce<br/>Marketplace API</h1>
			<p class="hero-subtitle">A comprehensive, phase-by-phase guide to mastering <strong>FastAPI</strong> by building a practical, real-world application from scratch.</p>
			<div class="hero-meta">
				<span class="meta-item">üêç Python + FastAPI</span>
				<span class="meta-item">üóÉÔ∏è SQLAlchemy + PostgreSQL</span>
				<span class="meta-item">üî¥ Redis + Celery</span>
				<span class="meta-item">üê≥ Docker</span>
			</div>
			<div class="hero-meta">
				<span class="meta-item">üì¶ 17 Phases</span>
				<span class="meta-item">üïê Self-Paced</span>
				<span class="meta-item">üéØ Beginner ‚Üí Intermediate</span>
			</div>
		</header>
		<!-- =========================================================== -->
		<!-- SECTION 1 ‚Äî PROJECT OVERVIEW & LEARNING GOALS               -->
		<!-- =========================================================== -->
		<section id="section-1" class="content-section">
			<div class="section-header">
				<span class="section-number">01</span>
				<h2 class="section-title">Project Overview &amp; Learning Goals</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>What this marketplace project is and, just as importantly, what it is <strong>not</strong>
					</li>
					<li>Which FastAPI concepts each phase teaches</li>
					<li>The three user roles and their permission boundaries</li>
					<li>The simplified feature list that covers all learning objectives</li>
					<li>What "production-ready" means for a learning project</li>
				</ul>
			</div>
			<!-- 1.1 What Is This Project? -->
			<h3 id="s1-what">1.1 What Is This Project?</h3>
			<p>
        This project is a <strong>simplified multi-vendor marketplace API</strong> ‚Äî think of it as a
        dramatically pared-down version of platforms like Etsy or a small-scale Amazon Marketplace.
        Multiple vendors can register, create stores, list products, and receive orders. Customers can
        browse products, add items to a cart, place orders, and leave reviews. An admin oversees the
        entire system.
      </p>
			<p>
        The emphasis is on <strong>learning FastAPI patterns</strong>, not on replicating every feature of a
        commercial marketplace. Every design decision in this project is made to maximize learning value
        while keeping complexity manageable.
      </p>
			<div class="callout callout-info">
				<div class="callout-header">üí° Scope Philosophy</div>
				<p>
          If a feature does not teach you a new FastAPI concept, it is either simplified or omitted entirely.
          For example, we do <strong>not</strong> build a coupon engine, complex inventory tracking, or
          multi-currency support. Each of those would add business-logic complexity without introducing new
          framework knowledge.
        </p>
			</div>
			<!-- 1.2 What FastAPI Concepts Each Phase Teaches -->
			<h3 id="s1-concepts">1.2 FastAPI Concepts by Phase</h3>
			<p>
        Every phase in this project is designed around one or more core FastAPI (or ecosystem) concepts.
        The table below maps each phase to the primary concepts it will teach you.
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Phase</th>
							<th>Feature</th>
							<th>Primary FastAPI / Ecosystem Concepts</th>
							<th>Priority</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>1</td>
							<td>Project Setup</td>
							<td>Application factory, settings with Pydantic, async database session, project layout</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>2</td>
							<td>Registration &amp; Login</td>
							<td>Pydantic schemas, password hashing, JWT creation, <span class="mono">APIRouter</span>
							</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>3</td>
							<td>Role-Based Access</td>
							<td>Dependency injection, <span class="mono">Depends()</span>, custom dependencies, permission guards</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>4</td>
							<td>Store Management</td>
							<td>Full CRUD pattern, path parameters, service layer pattern</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>5</td>
							<td>Categories</td>
							<td>Simple CRUD, admin-only routes, reusable dependency patterns</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>6</td>
							<td>Products</td>
							<td>Query parameters, pagination, filtering, search, relationship loading</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>7</td>
							<td>File Uploads</td>
							<td>
								<span class="mono">UploadFile</span>, <span class="mono">File()</span>, static file serving, file validation</td>
							<td>
								<span class="badge badge-important">Important</span>
							</td>
						</tr>
						<tr>
							<td>8</td>
							<td>Shopping Cart</td>
							<td>Nested Pydantic models, computed fields, stateful operations</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>9</td>
							<td>Orders</td>
							<td>Database transactions, status enums, multi-table writes, business logic in service layer</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>10</td>
							<td>Reviews</td>
							<td>Aggregate queries, conditional validation, relationship constraints</td>
							<td>
								<span class="badge badge-important">Important</span>
							</td>
						</tr>
						<tr>
							<td>11</td>
							<td>Addresses</td>
							<td>One-to-many relationships, default selection logic, reusable patterns</td>
							<td>
								<span class="badge badge-important">Important</span>
							</td>
						</tr>
						<tr>
							<td>12</td>
							<td>Background Tasks</td>
							<td>
								<span class="mono">BackgroundTasks</span>, Celery worker basics, task queues</td>
							<td>
								<span class="badge badge-important">Important</span>
							</td>
						</tr>
						<tr>
							<td>13</td>
							<td>Redis Caching</td>
							<td>Cache-aside pattern, cache invalidation, Redis connection, TTL strategies</td>
							<td>
								<span class="badge badge-important">Important</span>
							</td>
						</tr>
						<tr>
							<td>14</td>
							<td>WebSockets</td>
							<td>
								<span class="mono">WebSocket</span> endpoint, connection manager, real-time updates</td>
							<td>
								<span class="badge badge-optional">Optional Extension</span>
							</td>
						</tr>
						<tr>
							<td>15</td>
							<td>Middleware</td>
							<td>Custom middleware, request/response logging, CORS, error handling middleware</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>16</td>
							<td>Testing</td>
							<td>
								<span class="mono">TestClient</span>, pytest fixtures, database fixtures, async testing</td>
							<td>
								<span class="badge badge-core">Core</span>
							</td>
						</tr>
						<tr>
							<td>17</td>
							<td>Docker &amp; Deploy</td>
							<td>Dockerfile, Docker Compose, environment configuration, health checks</td>
							<td>
								<span class="badge badge-important">Important</span>
							</td>
						</tr>
					</tbody>
				</table>
			</div>
			<!-- 1.3 User Roles & Permissions -->
			<h3 id="s1-roles">1.3 User Roles &amp; Permissions</h3>
			<p>
        The marketplace has exactly <strong>three roles</strong>. Every user is assigned one role at
        registration time. For simplicity, a user cannot hold multiple roles simultaneously. The role is
        stored as a simple string enum field on the user record.
      </p>
			<div class="role-cards">
				<div class="role-card role-customer">
					<h4>üõçÔ∏è Customer</h4>
					<p class="role-desc">The default role. Browses products, manages a cart, places orders, writes reviews.</p>
					<ul>
						<li>Browse and search products</li>
						<li>Manage their own cart</li>
						<li>Place orders and view their order history</li>
						<li>Write one review per purchased product</li>
						<li>Manage their own addresses</li>
						<li>Update their own profile</li>
					</ul>
				</div>
				<div class="role-card role-vendor">
					<h4>üè™ Vendor</h4>
					<p class="role-desc">A seller. Creates a store, lists products, fulfills orders placed against their store.</p>
					<ul>
						<li>Everything a Customer can do</li>
						<li>Create and manage exactly one store</li>
						<li>Add, update, and remove products in their store</li>
						<li>View orders that contain their products</li>
						<li>Update order item status (e.g., shipped, delivered)</li>
						<li>Upload product images</li>
					</ul>
				</div>
				<div class="role-card role-admin">
					<h4>üõ°Ô∏è Admin</h4>
					<p class="role-desc">Platform administrator. Manages categories, monitors users, and oversees the marketplace.</p>
					<ul>
						<li>Everything a Vendor can do</li>
						<li>Create, update, and delete categories</li>
						<li>View and manage all users</li>
						<li>Activate or deactivate stores</li>
						<li>View all orders across the platform</li>
						<li>Access admin dashboard endpoints</li>
					</ul>
				</div>
			</div>
			<div class="callout callout-warn">
				<div class="callout-header">‚ö†Ô∏è Keep It Simple</div>
				<p>
          Do <strong>not</strong> build a full permission matrix or a dedicated permissions table. A single
          <span class="mono">role</span> field on the user model and a few reusable dependency functions
          are all you need for this project. The goal is to learn FastAPI's <span class="mono">Depends()</span>
          mechanism, not to build an enterprise RBAC system.
        </p>
			</div>
			<!-- 1.4 Feature List -->
			<h3 id="s1-features">1.4 Simplified Feature List</h3>
			<p>
        Below is the complete feature list for this project. Every feature is designed to teach specific
        FastAPI concepts. Features marked as <span class="badge badge-optional">Optional Extension</span>
        can be skipped without affecting the core learning path.
      </p>
			<div class="feature-grid">
				<div class="feature-group">
					<h4>Authentication &amp; Users</h4>
					<ul>
						<li>
							<span class="badge badge-core">Core</span> User registration with email and password</li>
						<li>
							<span class="badge badge-core">Core</span> Login with JWT access and refresh tokens</li>
						<li>
							<span class="badge badge-core">Core</span> Token refresh endpoint</li>
						<li>
							<span class="badge badge-core">Core</span> Get current user profile</li>
						<li>
							<span class="badge badge-important">Important</span> Update own profile</li>
					</ul>
				</div>
				<div class="feature-group">
					<h4>Store Management</h4>
					<ul>
						<li>
							<span class="badge badge-core">Core</span> Vendor creates a store</li>
						<li>
							<span class="badge badge-core">Core</span> Vendor updates their store details</li>
						<li>
							<span class="badge badge-core">Core</span> Anyone views a store's public profile</li>
						<li>
							<span class="badge badge-important">Important</span> Admin activates/deactivates a store</li>
						<li>
							<span class="badge badge-important">Important</span> List all stores with pagination</li>
					</ul>
				</div>
				<div class="feature-group">
					<h4>Categories</h4>
					<ul>
						<li>
							<span class="badge badge-core">Core</span> Admin creates a category</li>
						<li>
							<span class="badge badge-core">Core</span> Admin updates a category</li>
						<li>
							<span class="badge badge-core">Core</span> Anyone lists all categories</li>
						<li>
							<span class="badge badge-optional">Optional Extension</span> Admin deletes a category (only if no products)</li>
					</ul>
				</div>
				<div class="feature-group">
					<h4>Products</h4>
					<ul>
						<li>
							<span class="badge badge-core">Core</span> Vendor creates a product in their store</li>
						<li>
							<span class="badge badge-core">Core</span> Vendor updates their product</li>
						<li>
							<span class="badge badge-core">Core</span> Anyone views a product's detail</li>
						<li>
							<span class="badge badge-core">Core</span> Anyone lists products with pagination</li>
						<li>
							<span class="badge badge-core">Core</span> Filter products by category, store, price range</li>
						<li>
							<span class="badge badge-important">Important</span> Search products by name or description</li>
						<li>
							<span class="badge badge-important">Important</span> Vendor deletes (soft-deletes) their product</li>
					</ul>
				</div>
				<div class="feature-group">
					<h4>Cart &amp; Orders</h4>
					<ul>
						<li>
							<span class="badge badge-core">Core</span> Customer adds items to cart</li>
						<li>
							<span class="badge badge-core">Core</span> Customer views their cart</li>
						<li>
							<span class="badge badge-core">Core</span> Customer updates item quantity in cart</li>
						<li>
							<span class="badge badge-core">Core</span> Customer removes items from cart</li>
						<li>
							<span class="badge badge-core">Core</span> Customer places an order from cart</li>
						<li>
							<span class="badge badge-core">Core</span> Customer views their order history</li>
						<li>
							<span class="badge badge-core">Core</span> Customer views a specific order's details</li>
						<li>
							<span class="badge badge-important">Important</span> Vendor updates order item status</li>
					</ul>
				</div>
				<div class="feature-group">
					<h4>Reviews, Addresses &amp; Admin</h4>
					<ul>
						<li>
							<span class="badge badge-important">Important</span> Customer reviews a purchased product</li>
						<li>
							<span class="badge badge-important">Important</span> Anyone views reviews for a product</li>
						<li>
							<span class="badge badge-important">Important</span> Customer manages delivery addresses</li>
						<li>
							<span class="badge badge-important">Important</span> Admin views platform statistics</li>
						<li>
							<span class="badge badge-optional">Optional Extension</span> Admin manages all users</li>
					</ul>
				</div>
			</div>
			<!-- 1.5 What "Production-Ready" Means Here -->
			<h3 id="s1-production">1.5 What "Production-Ready" Means for a Learning Project</h3>
			<p>
        This project is <strong>not</strong> production software. However, it follows production
        <strong>patterns</strong> so that the habits you form here transfer directly to real-world work.
        Here is a simplified checklist of what "production-ready patterns" means in our context:
      </p>
			<div class="checklist">
				<div class="check-item">‚úÖ <strong>Input validation</strong> ‚Äî every endpoint validates incoming data with Pydantic</div>
				<div class="check-item">‚úÖ <strong>Consistent error responses</strong> ‚Äî all errors follow the same JSON structure</div>
				<div class="check-item">‚úÖ <strong>Authentication on all protected routes</strong> ‚Äî no endpoints accidentally left open</div>
				<div class="check-item">‚úÖ <strong>Layered architecture</strong> ‚Äî routers do not contain business logic or direct DB queries</div>
				<div class="check-item">‚úÖ <strong>Environment-based configuration</strong> ‚Äî no hardcoded secrets or connection strings</div>
				<div class="check-item">‚úÖ <strong>Database migrations</strong> ‚Äî schema changes tracked with Alembic</div>
				<div class="check-item">‚úÖ <strong>Automated tests</strong> ‚Äî key flows covered by tests</div>
				<div class="check-item">‚úÖ <strong>Docker support</strong> ‚Äî the app runs in containers</div>
				<div class="check-item">‚úÖ <strong>Logging</strong> ‚Äî structured logs for debugging</div>
				<div class="check-item">‚úÖ <strong>Health check endpoint</strong> ‚Äî basic operational readiness check</div>
			</div>
			<div class="callout callout-info">
				<div class="callout-header">üí° What We Intentionally Skip</div>
				<p>
          For a true production system you would also need: CI/CD pipelines, SSL/TLS termination,
          rate limiting infrastructure, monitoring and alerting, data backups, load balancing,
          and much more. Those are operational concerns outside FastAPI's scope and are not covered here.
        </p>
			</div>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 2 ‚Äî ARCHITECTURE & DESIGN DECISIONS                 -->
		<!-- =========================================================== -->
		<section id="section-2" class="content-section">
			<div class="section-header">
				<span class="section-number">02</span>
				<h2 class="section-title">Architecture &amp; Design Decisions</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>How the overall system fits together (application, database, cache, task worker)</li>
					<li>The layered architecture pattern and why it matters</li>
					<li>How FastAPI's dependency injection system works and how to leverage it</li>
					<li>Configuration management with Pydantic Settings</li>
					<li>API design conventions you will follow consistently</li>
					<li>The JWT authentication flow from login to protected endpoint</li>
					<li>When and why to use background tasks vs. Celery</li>
					<li>A simple caching strategy with Redis</li>
				</ul>
			</div>
			<!-- 2.1 System Architecture -->
			<h3 id="s2-system">2.1 System Architecture Overview</h3>
			<p>
        Even though this is a <strong>monolithic application</strong> (a single deployable unit, not
        microservices), it interacts with several infrastructure components. Understanding how they
        connect will help you reason about the system as a whole.
      </p>
			<div class="arch-diagram">
				<div class="arch-box arch-client">
					<strong>Client</strong>
					<span>Any HTTP client: browser, Postman, mobile app, or the auto-generated Swagger UI</span>
				</div>
				<div class="arch-arrow">‚¨áÔ∏è HTTP / WebSocket</div>
				<div class="arch-box arch-app">
					<strong>FastAPI Application</strong>
					<span>Routers ‚Üí Services ‚Üí Repositories ‚Üí Models</span>
				</div>
				<div class="arch-connections">
					<div class="arch-conn">
						<div class="arch-arrow">‚¨áÔ∏è SQL (async)</div>
						<div class="arch-box arch-db">
							<strong>PostgreSQL</strong>
							<span>Primary data store</span>
						</div>
					</div>
					<div class="arch-conn">
						<div class="arch-arrow">‚¨áÔ∏è GET/SET</div>
						<div class="arch-box arch-cache">
							<strong>Redis</strong>
							<span>Caching &amp; Celery broker</span>
						</div>
					</div>
					<div class="arch-conn">
						<div class="arch-arrow">‚¨áÔ∏è Task queue</div>
						<div class="arch-box arch-worker">
							<strong>Celery Worker</strong>
							<span>Background jobs</span>
						</div>
					</div>
				</div>
			</div>
			<p>
				<strong>PostgreSQL</strong> stores all persistent data: users, products, orders, and so on.
        <strong>Redis</strong> serves two purposes ‚Äî it acts as a cache for frequently-read data (like
        category lists) and as the message broker for Celery. The <strong>Celery worker</strong> runs as a
        separate process and handles tasks that should not block the API response, like sending email
        notifications. During development, all of these run locally via Docker Compose.
      </p>
			<!-- 2.2 Layered Architecture -->
			<h3 id="s2-layers">2.2 Layered Architecture: Router ‚Üí Service ‚Üí Repository ‚Üí Model</h3>
			<p>
        The single most important architectural decision in this project is the <strong>layered
        architecture</strong>. Every request flows through four distinct layers, each with a clear
        responsibility. This separation keeps your code testable, maintainable, and easy to reason about.
      </p>
			<div class="layers-diagram">
				<div class="layer layer-router">
					<div class="layer-label">Router Layer</div>
					<div class="layer-desc">
						<strong>Responsibility:</strong> Accepts HTTP requests, validates input via Pydantic schemas,
            calls the appropriate service function, and returns the HTTP response with the correct status code.
          </div>
					<div class="layer-rules">
						<strong>Rules:</strong> No business logic. No direct database access. No SQL. Just
            request-in, response-out orchestration.
          </div>
				</div>
				<div class="layer-arrow">‚¨áÔ∏è</div>
				<div class="layer layer-service">
					<div class="layer-label">Service Layer</div>
					<div class="layer-desc">
						<strong>Responsibility:</strong> Contains all business logic. Validates business rules
            (e.g., "a customer can only review a product they have purchased"), orchestrates
            multiple repository calls when needed, and raises application-specific exceptions.
          </div>
					<div class="layer-rules">
						<strong>Rules:</strong> No knowledge of HTTP (no status codes, no request/response objects).
            No direct SQL. Calls repository methods only.
          </div>
				</div>
				<div class="layer-arrow">‚¨áÔ∏è</div>
				<div class="layer layer-repo">
					<div class="layer-label">Repository Layer</div>
					<div class="layer-desc">
						<strong>Responsibility:</strong> All database operations. Each repository handles one model
            (table). Provides methods like <span class="mono">get_by_id</span>,
            <span class="mono">get_all</span>, <span class="mono">create</span>,
            <span class="mono">update</span>, <span class="mono">delete</span>.
          </div>
					<div class="layer-rules">
						<strong>Rules:</strong> No business logic. No HTTP awareness. Pure data access.
            Receives a database session via dependency injection.
          </div>
				</div>
				<div class="layer-arrow">‚¨áÔ∏è</div>
				<div class="layer layer-model">
					<div class="layer-label">Model Layer</div>
					<div class="layer-desc">
						<strong>Responsibility:</strong> SQLAlchemy ORM models that map to database tables.
            Defines columns, data types, constraints, and relationships.
          </div>
					<div class="layer-rules">
						<strong>Rules:</strong> Purely declarative. No logic, no queries.
          </div>
				</div>
			</div>
			<div class="callout callout-info">
				<div class="callout-header">üí° Why This Matters</div>
				<p>
          When your router function is just five lines ‚Äî parse input, call service, return output ‚Äî it
          becomes trivially easy to test, debug, and modify. When your service layer knows nothing about
          HTTP, you can reuse it from a CLI tool, a background task, or a different API version without
          changes. This separation is the foundation of maintainable backend code, and FastAPI's dependency
          injection makes it natural to implement.
        </p>
			</div>
			<!-- 2.3 Dependency Injection in FastAPI -->
			<h3 id="s2-di">2.3 How Dependency Injection Works in FastAPI</h3>
			<p>
        Dependency injection (DI) is <strong>FastAPI's superpower</strong>. Understanding it deeply is
        perhaps the single most important thing you will learn in this project. Here is how it works
        conceptually:
      </p>
			<ol>
				<li>
          You write a function (or a class with a <span class="mono">__call__</span> method) that
          produces something your route handler needs ‚Äî a database session, the current authenticated user,
          a service instance, or a permission check result.
        </li>
				<li>
          You declare that function as a <strong>dependency</strong> in your route handler's signature
          using <span class="mono">Depends(your_function)</span>.
        </li>
				<li>
          When a request arrives, FastAPI automatically calls your dependency function
          <strong>before</strong> calling the route handler, passes the result into the handler's parameter,
          and ‚Äî if the dependency is a generator ‚Äî cleans up afterward.
        </li>
				<li>
          Dependencies can depend on <strong>other dependencies</strong>, forming a dependency tree that
          FastAPI resolves automatically.
        </li>
			</ol>
			<h4>Common Dependencies in This Project</h4>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Dependency</th>
							<th>What It Provides</th>
							<th>Used By</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<span class="mono">get_db</span>
							</td>
							<td>An async SQLAlchemy session, automatically closed after the request</td>
							<td>Every repository and most route handlers</td>
						</tr>
						<tr>
							<td>
								<span class="mono">get_current_user</span>
							</td>
							<td>The authenticated user object, extracted from the JWT in the Authorization header</td>
							<td>All protected routes</td>
						</tr>
						<tr>
							<td>
								<span class="mono">require_role("admin")</span>
							</td>
							<td>A guard that raises a 403 error if the current user does not have the required role</td>
							<td>Admin-only routes</td>
						</tr>
						<tr>
							<td>
								<span class="mono">get_product_service</span>
							</td>
							<td>An instance of the product service, pre-wired with a repository and database session</td>
							<td>Product router endpoints</td>
						</tr>
					</tbody>
				</table>
			</div>
			<p>
        The key insight is that dependencies are <strong>composable</strong>. Your
        <span class="mono">require_role</span> dependency internally calls
        <span class="mono">get_current_user</span>, which internally calls
        <span class="mono">get_db</span>. You declare only the outermost dependency you need, and FastAPI
        resolves the entire chain. This is what makes the layered architecture so clean ‚Äî each layer gets
        its dependencies injected, never constructing them manually.
      </p>
			<!-- 2.4 Configuration Management -->
			<h3 id="s2-config">2.4 Configuration Management</h3>
			<p>
        All configuration values ‚Äî database URL, secret keys, Redis URL, debug flags ‚Äî come from
        <strong>environment variables</strong>. You will use Pydantic's
        <span class="mono">BaseSettings</span> class to define, validate, and type-cast these values
        at application startup.
      </p>
			<p>
        The settings class reads from a <span class="mono">.env</span> file during local development
        and from actual environment variables in Docker/production. Pydantic validates the values
        automatically ‚Äî if a required variable is missing or has the wrong type, the application
        <strong>refuses to start</strong> with a clear error message. This is vastly better than
        discovering a misconfigured setting at runtime when a user hits an endpoint.
      </p>
			<p>
        You create a <strong>single global settings instance</strong> (using a cached function or
        module-level variable) and access it via dependency injection wherever needed. Key settings
        to define include:
      </p>
			<ul>
				<li>
					<strong>DATABASE_URL</strong> ‚Äî the PostgreSQL connection string (async variant)</li>
				<li>
					<strong>SECRET_KEY</strong> ‚Äî used for signing JWTs</li>
				<li>
					<strong>ACCESS_TOKEN_EXPIRE_MINUTES</strong> ‚Äî JWT access token lifetime</li>
				<li>
					<strong>REFRESH_TOKEN_EXPIRE_DAYS</strong> ‚Äî JWT refresh token lifetime</li>
				<li>
					<strong>REDIS_URL</strong> ‚Äî connection string for Redis</li>
				<li>
					<strong>DEBUG</strong> ‚Äî enables/disables debug mode</li>
				<li>
					<strong>ALLOWED_ORIGINS</strong> ‚Äî CORS allowed origins list</li>
			</ul>
			<!-- 2.5 Database Design Basics -->
			<h3 id="s2-dbdesign">2.5 Database Design Basics</h3>
			<p>
        The database design follows standard relational patterns. A few guiding principles:
      </p>
			<ul>
				<li>
					<strong>Use UUIDs for primary keys</strong> ‚Äî they are harder to guess than auto-incrementing
          integers (better for API security) and make database merging simpler. FastAPI handles UUID
          serialization seamlessly.
        </li>
				<li>
					<strong>Use timestamps on every table</strong> ‚Äî include <span class="mono">created_at</span>
          and <span class="mono">updated_at</span> columns on every model. Define these in a shared base
          model class so you never forget.
        </li>
				<li>
					<strong>Soft deletes where appropriate</strong> ‚Äî for products and stores, use an
          <span class="mono">is_active</span> boolean rather than actually deleting rows. This preserves
          order history integrity.
        </li>
				<li>
					<strong>Keep normalization reasonable</strong> ‚Äî normalize to third normal form where it
          makes sense, but do not over-normalize. For example, storing the price on the
          <span class="mono">order_items</span> table (snapshotting the price at order time) is
          intentional denormalization.
        </li>
				<li>
					<strong>Use enums for status fields</strong> ‚Äî order status, user role, and similar fields
          should use Python enums mapped to database string columns. This gives you type safety in
          Python and readability in the database.
        </li>
			</ul>
			<!-- 2.6 API Design Conventions -->
			<h3 id="s2-api-conventions">2.6 API Design Conventions</h3>
			<p>
        Consistency in API design makes your API predictable for consumers and easier for you to maintain.
        Follow these conventions throughout:
      </p>
			<h4>URL Patterns</h4>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Pattern</th>
							<th>Convention</th>
							<th>Example</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>API prefix</td>
							<td>All endpoints under <span class="mono">/api/v1/</span>
							</td>
							<td>
								<span class="mono">/api/v1/products</span>
							</td>
						</tr>
						<tr>
							<td>Resource collections</td>
							<td>Plural nouns, lowercase</td>
							<td>
								<span class="mono">/api/v1/products</span>
							</td>
						</tr>
						<tr>
							<td>Single resource</td>
							<td>Collection path + <span class="mono">/{id}</span>
							</td>
							<td>
								<span class="mono">/api/v1/products/{product_id}</span>
							</td>
						</tr>
						<tr>
							<td>Nested resources</td>
							<td>Parent collection + ID + child collection</td>
							<td>
								<span class="mono">/api/v1/products/{product_id}/reviews</span>
							</td>
						</tr>
						<tr>
							<td>Current user actions</td>
							<td>Use <span class="mono">/me/</span> prefix</td>
							<td>
								<span class="mono">/api/v1/me/orders</span>
							</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h4>HTTP Methods</h4>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Method</th>
							<th>Purpose</th>
							<th>Response Code</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<span class="mono">GET</span>
							</td>
							<td>Retrieve a resource or list of resources</td>
							<td>200 OK</td>
						</tr>
						<tr>
							<td>
								<span class="mono">POST</span>
							</td>
							<td>Create a new resource</td>
							<td>201 Created</td>
						</tr>
						<tr>
							<td>
								<span class="mono">PUT</span>
							</td>
							<td>Full update of a resource (replace all fields)</td>
							<td>200 OK</td>
						</tr>
						<tr>
							<td>
								<span class="mono">PATCH</span>
							</td>
							<td>Partial update of a resource (only specified fields)</td>
							<td>200 OK</td>
						</tr>
						<tr>
							<td>
								<span class="mono">DELETE</span>
							</td>
							<td>Remove a resource</td>
							<td>204 No Content</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h4>Standard Response Format</h4>
			<p>
        All successful responses that return data use a consistent envelope structure. For single
        resources, the response body contains the resource fields directly. For collections (lists),
        wrap the results in a pagination envelope:
      </p>
			<ul>
				<li>
					<strong>items</strong> ‚Äî the list of resource objects</li>
				<li>
					<strong>total</strong> ‚Äî total number of matching records</li>
				<li>
					<strong>page</strong> ‚Äî current page number</li>
				<li>
					<strong>size</strong> ‚Äî items per page</li>
				<li>
					<strong>pages</strong> ‚Äî total number of pages</li>
			</ul>
			<h4>Standard Error Response Format</h4>
			<p>
        All error responses follow a uniform structure so that API consumers can parse errors
        consistently:
      </p>
			<ul>
				<li>
					<strong>detail</strong> ‚Äî a human-readable error message</li>
				<li>
					<strong>error_code</strong> ‚Äî a machine-readable error identifier (e.g., "USER_NOT_FOUND", "INVALID_CREDENTIALS")</li>
			</ul>
			<p>
        FastAPI's built-in validation errors (422 responses) already follow Pydantic's error format.
        You do not need to override those ‚Äî only ensure your custom errors are consistent.
      </p>
			<!-- 2.7 Error Handling Approach -->
			<h3 id="s2-errors">2.7 Error Handling Approach</h3>
			<p>
        Define a set of <strong>custom exception classes</strong> in a shared module. Each exception
        maps to an HTTP status code and carries a detail message and an error code. Use FastAPI's
        <strong>exception handlers</strong> (registered at the application level) to catch these
        custom exceptions and convert them into proper JSON error responses.
      </p>
			<p>
        The key exceptions you will need:
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Exception</th>
							<th>HTTP Status</th>
							<th>When to Raise</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<span class="mono">NotFoundException</span>
							</td>
							<td>404</td>
							<td>Requested resource does not exist</td>
						</tr>
						<tr>
							<td>
								<span class="mono">BadRequestException</span>
							</td>
							<td>400</td>
							<td>Request is logically invalid (e.g., ordering from an empty cart)</td>
						</tr>
						<tr>
							<td>
								<span class="mono">UnauthorizedException</span>
							</td>
							<td>401</td>
							<td>Missing or invalid authentication credentials</td>
						</tr>
						<tr>
							<td>
								<span class="mono">ForbiddenException</span>
							</td>
							<td>403</td>
							<td>Authenticated but not permitted (wrong role, not the resource owner)</td>
						</tr>
						<tr>
							<td>
								<span class="mono">ConflictException</span>
							</td>
							<td>409</td>
							<td>Duplicate resource (e.g., email already registered, vendor already has a store)</td>
						</tr>
					</tbody>
				</table>
			</div>
			<p>
        The service layer raises these exceptions. The router layer does <strong>not</strong> catch
        them ‚Äî they bubble up to FastAPI's exception handler, which converts them to the correct HTTP
        response. This keeps your router code clean and your error handling centralized.
      </p>
			<!-- 2.8 JWT Authentication Flow -->
			<h3 id="s2-jwt">2.8 JWT Authentication Flow</h3>
			<p>
        JSON Web Tokens (JWTs) are the authentication mechanism for this API. Here is the complete
        flow, step by step:
      </p>
			<ol>
				<li>
					<strong>Registration:</strong> The client sends a POST request with email, password, full name,
          and desired role. The server hashes the password using <span class="mono">bcrypt</span>, stores
          the user in the database, and returns the user profile (without password). No tokens are issued
          at registration ‚Äî the user must log in.
        </li>
				<li>
					<strong>Login:</strong> The client sends email and password. The server verifies the credentials
          against the stored hash. If valid, the server generates two tokens:
          <ul>
						<li>
							<strong>Access Token</strong> ‚Äî short-lived (e.g., 30 minutes). Contains the user's ID
              and role in the payload. Used for authenticating API requests.</li>
						<li>
							<strong>Refresh Token</strong> ‚Äî longer-lived (e.g., 7 days). Used solely to obtain a
              new access token without re-entering credentials.</li>
					</ul>
				</li>
				<li>
					<strong>Authenticated Requests:</strong> The client includes the access token in the
          <span class="mono">Authorization</span> header as a Bearer token. On every protected endpoint,
          a dependency function extracts the token, decodes and validates it, loads the user from the
          database, and provides the user object to the route handler.
        </li>
				<li>
					<strong>Token Refresh:</strong> When the access token expires, the client sends the refresh
          token to the refresh endpoint. The server validates the refresh token, and if valid, issues a
          new access token (and optionally a new refresh token).
        </li>
				<li>
					<strong>Failed Authentication:</strong> If the token is missing, expired, or invalid, the
          dependency raises a 401 Unauthorized error before the route handler is even called.
        </li>
			</ol>
			<div class="callout callout-warn">
				<div class="callout-header">‚ö†Ô∏è Security Note</div>
				<p>
          For this learning project, we store JWTs only on the client side (stateless authentication).
          We do <strong>not</strong> implement token blacklisting or server-side session storage. In a
          real production system, you would want a way to invalidate tokens (e.g., a Redis-based blacklist
          or short token lifetimes combined with refresh token rotation). Understanding the basic JWT flow
          is the learning goal here.
        </p>
			</div>
			<!-- 2.9 Caching Strategy -->
			<h3 id="s2-caching">2.9 Simple Caching Strategy</h3>
			<p>
        Caching is introduced in Phase 13 using Redis. The strategy is intentionally simple ‚Äî
        <strong>cache-aside</strong> (also called lazy loading):
      </p>
			<ol>
				<li>When a request comes in, check if the data exists in Redis.</li>
				<li>If it does (cache hit), return the cached data immediately ‚Äî skip the database.</li>
				<li>If it does not (cache miss), query the database, store the result in Redis with a
          time-to-live (TTL), and then return the data.</li>
				<li>When the underlying data changes (create, update, delete), invalidate (delete) the
          relevant cache keys so that the next read fetches fresh data.</li>
			</ol>
			<p>
				<strong>What to cache in this project:</strong>
			</p>
			<ul>
				<li>
					<strong>Category list</strong> ‚Äî changes rarely, read on nearly every product browse. Cache with a long TTL (e.g., one hour).</li>
				<li>
					<strong>Individual product details</strong> ‚Äî frequently read product pages. Cache with a medium TTL (e.g., fifteen minutes). Invalidate when the product is updated.</li>
				<li>
					<strong>Store public profiles</strong> ‚Äî moderate read frequency. Cache similarly to products.</li>
			</ul>
			<p>
				<strong>What NOT to cache:</strong>
			</p>
			<ul>
				<li>User-specific data (carts, orders, profiles) ‚Äî too many unique keys, frequent changes, low cache hit rate.</li>
				<li>Search results ‚Äî the query space is too large to cache effectively at this scale.</li>
			</ul>
			<!-- 2.10 When to Use Background Tasks -->
			<h3 id="s2-background">2.10 When to Use Background Tasks</h3>
			<p>
        FastAPI offers two mechanisms for work that should not block the API response:
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Mechanism</th>
							<th>Best For</th>
							<th>Limitations</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<strong>FastAPI BackgroundTasks</strong>
							</td>
							<td>Quick, fire-and-forget tasks that run in the same process. Example: logging an analytics event, sending a simple notification.</td>
							<td>Runs in the same process ‚Äî if the server restarts, the task is lost. Not suitable for long-running or critical tasks.</td>
						</tr>
						<tr>
							<td>
								<strong>Celery</strong>
							</td>
							<td>Tasks that are longer-running, need retries, or must survive server restarts. Example: sending an email, generating a report, processing an image.</td>
							<td>Requires a separate worker process and a message broker (Redis). More infrastructure complexity.</td>
						</tr>
					</tbody>
				</table>
			</div>
			<p>
				<strong>In this project</strong>, you will use FastAPI's <span class="mono">BackgroundTasks</span>
        for simple post-response work (like logging order placement) and Celery for simulated email
        sending. The goal is to understand both mechanisms and know when to reach for each one.
      </p>
			<!-- 2.11 Logging Approach -->
			<h3 id="s2-logging">2.11 Basic Logging Approach</h3>
			<p>
        Use Python's built-in <span class="mono">logging</span> module, configured once at application
        startup. Follow these practices:
      </p>
			<ul>
				<li>
					<strong>Use structured log messages</strong> ‚Äî include context like user ID, request ID,
          and resource identifiers. This makes logs searchable and debuggable.
        </li>
				<li>
					<strong>Log at appropriate levels:</strong>
					<span class="mono">DEBUG</span> for development detail,
          <span class="mono">INFO</span> for normal operations (request received, order placed),
          <span class="mono">WARNING</span> for recoverable issues (invalid login attempt),
          <span class="mono">ERROR</span> for failures that need attention (database connection lost).
        </li>
				<li>
					<strong>Do not log sensitive data</strong> ‚Äî never log passwords, tokens, or full credit card
          numbers. Log user IDs, not their personal information.
        </li>
				<li>
					<strong>Add a request ID middleware</strong> ‚Äî generate a unique ID for each request and
          include it in all logs for that request. This lets you trace a single request's journey through
          the system.
        </li>
			</ul>
			<div class="callout callout-info">
				<div class="callout-header">üí° Logging vs. Print Statements</div>
				<p>
          Never use <span class="mono">print()</span> for debugging in a FastAPI application. The logging
          module gives you levels, formatting, timestamps, and the ability to route logs to files or
          external services. It is a production habit worth forming from day one.
        </p>
			</div>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 3 ‚Äî DATABASE SCHEMA & RELATIONSHIPS                 -->
		<!-- =========================================================== -->
		<section id="section-3" class="content-section">
			<div class="section-header">
				<span class="section-number">03</span>
				<h2 class="section-title">Database Schema &amp; Relationships</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>Every database table needed for the marketplace, its purpose, and its columns</li>
					<li>Data types, constraints, and why each choice matters</li>
					<li>How tables relate to each other through foreign keys</li>
					<li>The difference between required relationships and optional extensions</li>
					<li>Database design patterns like soft deletes, timestamp mixins, and price snapshots</li>
				</ul>
			</div>
			<p>
        This section documents every table in the database. For each table you will find: the table
        name and its purpose, every column with its data type and constraints, and the relationships
        that connect it to other tables. Read this section <strong>before</strong> starting Phase 1 so
        you have the full picture. You will implement the models incrementally, phase by phase.
      </p>
			<div class="callout callout-info">
				<div class="callout-header">üí° Shared Columns Convention</div>
				<p>
          Every table includes three common columns inherited from a shared base model class:
          <span class="mono">id</span> (UUID, primary key, auto-generated),
          <span class="mono">created_at</span> (timestamp, set on creation), and
          <span class="mono">updated_at</span> (timestamp, updated on every modification).
          These are <strong>not repeated</strong> in the individual table descriptions below.
        </p>
			</div>
			<!-- ===== TABLE: users ===== -->
			<div class="schema-card" id="schema-users">
				<h3 class="schema-title">
					<span class="schema-icon">üë§</span>
          users
          <span class="badge badge-core">Core</span>
				</h3>
				<p class="schema-purpose">
          Stores all registered users regardless of role. The <span class="mono">role</span> field
          determines what a user can do across the platform.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">email</span>
								</td>
								<td>String(255)</td>
								<td>Unique, Not Null, Indexed</td>
								<td>User's login identifier. Validate email format with Pydantic.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">hashed_password</span>
								</td>
								<td>String(255)</td>
								<td>Not Null</td>
								<td>Bcrypt hash of the password. Never store or return plain passwords.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">full_name</span>
								</td>
								<td>String(100)</td>
								<td>Not Null</td>
								<td>Display name of the user.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">role</span>
								</td>
								<td>String(20)</td>
								<td>Not Null, Default: "customer"</td>
								<td>One of: <span class="mono">customer</span>, <span class="mono">vendor</span>, <span class="mono">admin</span>. Use a Python enum.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">is_active</span>
								</td>
								<td>Boolean</td>
								<td>Not Null, Default: True</td>
								<td>Allows admin to deactivate accounts without deleting them.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">phone</span>
								</td>
								<td>String(20)</td>
								<td>Nullable</td>
								<td>Optional contact phone number.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>One-to-One</strong> with <span class="mono">stores</span> ‚Äî a vendor user can own exactly one store</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">addresses</span> ‚Äî a user can have multiple delivery addresses</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">orders</span> ‚Äî a user can place multiple orders</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">reviews</span> ‚Äî a user can write multiple reviews</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">cart_items</span> ‚Äî a user's shopping cart items</li>
					</ul>
				</div>
			</div>
			<!-- ===== TABLE: stores ===== -->
			<div class="schema-card" id="schema-stores">
				<h3 class="schema-title">
					<span class="schema-icon">üè™</span>
          stores
          <span class="badge badge-core">Core</span>
				</h3>
				<p class="schema-purpose">
          Represents a vendor's shop on the marketplace. Each vendor has exactly one store.
          The store has its own name, description, and status independent of the user account.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">owner_id</span>
								</td>
								<td>UUID (FK ‚Üí users.id)</td>
								<td>Unique, Not Null</td>
								<td>The vendor who owns this store. Unique enforces one store per vendor.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">name</span>
								</td>
								<td>String(100)</td>
								<td>Unique, Not Null</td>
								<td>Public display name of the store.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">description</span>
								</td>
								<td>Text</td>
								<td>Nullable</td>
								<td>A longer description of what the store sells.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">is_active</span>
								</td>
								<td>Boolean</td>
								<td>Not Null, Default: True</td>
								<td>Admin can deactivate stores. Inactive stores' products are hidden from search.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">users</span> ‚Äî belongs to one vendor user</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">products</span> ‚Äî a store can list many products</li>
					</ul>
				</div>
			</div>
			<!-- ===== TABLE: categories ===== -->
			<div class="schema-card" id="schema-categories">
				<h3 class="schema-title">
					<span class="schema-icon">üè∑Ô∏è</span>
          categories
          <span class="badge badge-core">Core</span>
				</h3>
				<p class="schema-purpose">
          A flat list of product categories managed by admins. No hierarchy or nesting ‚Äî each
          product belongs to exactly one category. Keeping categories flat dramatically simplifies
          queries and is sufficient for learning.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">name</span>
								</td>
								<td>String(50)</td>
								<td>Unique, Not Null</td>
								<td>Category display name. Examples: "Electronics", "Clothing", "Books".</td>
							</tr>
							<tr>
								<td>
									<span class="mono">slug</span>
								</td>
								<td>String(60)</td>
								<td>Unique, Not Null, Indexed</td>
								<td>URL-friendly version of the name (e.g., "electronics"). Generate from name.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">description</span>
								</td>
								<td>String(255)</td>
								<td>Nullable</td>
								<td>Optional short description of the category.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">is_active</span>
								</td>
								<td>Boolean</td>
								<td>Not Null, Default: True</td>
								<td>Inactive categories are hidden from product browse.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">products</span> ‚Äî a category contains many products</li>
					</ul>
				</div>
			</div>
			<!-- ===== TABLE: products ===== -->
			<div class="schema-card" id="schema-products">
				<h3 class="schema-title">
					<span class="schema-icon">üì¶</span>
          products
          <span class="badge badge-core">Core</span>
				</h3>
				<p class="schema-purpose">
          The central entity of the marketplace. Each product belongs to one store and one category.
          Products have a price, stock count, and descriptive information. Soft-deleted via
          <span class="mono">is_active</span>.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">store_id</span>
								</td>
								<td>UUID (FK ‚Üí stores.id)</td>
								<td>Not Null, Indexed</td>
								<td>The store that lists this product.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">category_id</span>
								</td>
								<td>UUID (FK ‚Üí categories.id)</td>
								<td>Not Null, Indexed</td>
								<td>The category this product belongs to.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">name</span>
								</td>
								<td>String(200)</td>
								<td>Not Null</td>
								<td>Product display name. Searchable.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">description</span>
								</td>
								<td>Text</td>
								<td>Nullable</td>
								<td>Detailed product description. Searchable.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">price</span>
								</td>
								<td>Numeric(10, 2)</td>
								<td>Not Null, Check: price &gt; 0</td>
								<td>Price in base currency. Use Numeric for precision, never Float.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">stock</span>
								</td>
								<td>Integer</td>
								<td>Not Null, Default: 0, Check: stock &gt;= 0</td>
								<td>Available quantity. Decremented when orders are placed.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">is_active</span>
								</td>
								<td>Boolean</td>
								<td>Not Null, Default: True</td>
								<td>Soft delete flag. Inactive products are excluded from search and browse.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">stores</span> ‚Äî belongs to one store</li>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">categories</span> ‚Äî belongs to one category</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">product_images</span> ‚Äî can have multiple images</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">order_items</span> ‚Äî can appear in many order line items</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">reviews</span> ‚Äî can have many customer reviews</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">cart_items</span> ‚Äî can be in many customers' carts</li>
					</ul>
				</div>
				<div class="callout callout-info">
					<div class="callout-header">üí° Why Numeric and Not Float?</div>
					<p>
            Floating-point numbers have precision issues (e.g., 0.1 + 0.2 ‚â† 0.3 in most languages).
            For monetary values, always use <span class="mono">Numeric</span> (or
            <span class="mono">Decimal</span>) which stores exact decimal values. In SQLAlchemy, use
            <span class="mono">Numeric(precision=10, scale=2)</span> to allow values up to
            99,999,999.99 with exact two-decimal precision. In Pydantic, use
            <span class="mono">condecimal</span> or <span class="mono">Decimal</span> for the
            corresponding schema field.
          </p>
				</div>
			</div>
			<!-- ===== TABLE: product_images ===== -->
			<div class="schema-card" id="schema-product-images">
				<h3 class="schema-title">
					<span class="schema-icon">üñºÔ∏è</span>
          product_images
          <span class="badge badge-important">Important</span>
				</h3>
				<p class="schema-purpose">
          Stores file paths for product images. Each product can have multiple images.
          One image can be marked as the primary display image.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">product_id</span>
								</td>
								<td>UUID (FK ‚Üí products.id)</td>
								<td>Not Null, Indexed</td>
								<td>The product this image belongs to.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">image_url</span>
								</td>
								<td>String(500)</td>
								<td>Not Null</td>
								<td>Relative path to the stored image file on the server.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">is_primary</span>
								</td>
								<td>Boolean</td>
								<td>Not Null, Default: False</td>
								<td>Only one image per product should be primary. Enforce in business logic.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">sort_order</span>
								</td>
								<td>Integer</td>
								<td>Not Null, Default: 0</td>
								<td>Display ordering of images.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">products</span> ‚Äî belongs to one product</li>
					</ul>
				</div>
			</div>
			<!-- ===== TABLE: orders ===== -->
			<div class="schema-card" id="schema-orders">
				<h3 class="schema-title">
					<span class="schema-icon">üìã</span>
          orders
          <span class="badge badge-core">Core</span>
				</h3>
				<p class="schema-purpose">
          Represents a customer's order. An order is created from the cart and contains one or more
          order items. The order tracks the overall status and total amount.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">user_id</span>
								</td>
								<td>UUID (FK ‚Üí users.id)</td>
								<td>Not Null, Indexed</td>
								<td>The customer who placed the order.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">shipping_address_id</span>
								</td>
								<td>UUID (FK ‚Üí addresses.id)</td>
								<td>Not Null</td>
								<td>The delivery address for this order.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">status</span>
								</td>
								<td>String(20)</td>
								<td>Not Null, Default: "pending"</td>
								<td>Overall order status. Values: <span class="mono">pending</span>, <span class="mono">confirmed</span>, <span class="mono">shipped</span>, <span class="mono">delivered</span>, <span class="mono">cancelled</span>.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">total_amount</span>
								</td>
								<td>Numeric(12, 2)</td>
								<td>Not Null</td>
								<td>Sum of all order item subtotals. Calculated at order creation time.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">order_number</span>
								</td>
								<td>String(20)</td>
								<td>Unique, Not Null</td>
								<td>Human-readable order identifier (e.g., "ORD-20240115-001"). Generated by the service layer.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">users</span> ‚Äî placed by one customer</li>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">addresses</span> ‚Äî shipped to one address</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">order_items</span> ‚Äî contains one or more line items</li>
					</ul>
				</div>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Order Status Transitions</div>
					<p>
            Status changes should follow a defined flow:
            <span class="mono">pending ‚Üí confirmed ‚Üí shipped ‚Üí delivered</span>. A
            <span class="mono">cancelled</span> status can be reached from
            <span class="mono">pending</span> or <span class="mono">confirmed</span> only. Enforce
            these valid transitions in the service layer ‚Äî do not allow arbitrary status changes.
          </p>
				</div>
			</div>
			<!-- ===== TABLE: order_items ===== -->
			<div class="schema-card" id="schema-order-items">
				<h3 class="schema-title">
					<span class="schema-icon">üìù</span>
          order_items
          <span class="badge badge-core">Core</span>
				</h3>
				<p class="schema-purpose">
          A line item within an order. Records the product, quantity, and the price at the time of
          ordering. The price is <strong>snapshotted</strong> ‚Äî it does not change if the product
          price later updates.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">order_id</span>
								</td>
								<td>UUID (FK ‚Üí orders.id)</td>
								<td>Not Null, Indexed</td>
								<td>The order this item belongs to.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">product_id</span>
								</td>
								<td>UUID (FK ‚Üí products.id)</td>
								<td>Not Null</td>
								<td>The product being ordered.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">store_id</span>
								</td>
								<td>UUID (FK ‚Üí stores.id)</td>
								<td>Not Null</td>
								<td>The store the product belongs to. Stored here for efficient vendor order queries.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">quantity</span>
								</td>
								<td>Integer</td>
								<td>Not Null, Check: quantity &gt; 0</td>
								<td>How many units of the product were ordered.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">unit_price</span>
								</td>
								<td>Numeric(10, 2)</td>
								<td>Not Null</td>
								<td>Price per unit at the time the order was placed. This is a snapshot, not a live reference.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">subtotal</span>
								</td>
								<td>Numeric(12, 2)</td>
								<td>Not Null</td>
								<td>Calculated as <span class="mono">quantity √ó unit_price</span>. Stored for query convenience.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">status</span>
								</td>
								<td>String(20)</td>
								<td>Not Null, Default: "pending"</td>
								<td>Item-level status. Allows different vendors to update status for their own items independently.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">orders</span> ‚Äî belongs to one order</li>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">products</span> ‚Äî references one product</li>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">stores</span> ‚Äî references one store</li>
					</ul>
				</div>
			</div>
			<!-- ===== TABLE: reviews ===== -->
			<div class="schema-card" id="schema-reviews">
				<h3 class="schema-title">
					<span class="schema-icon">‚≠ê</span>
          reviews
          <span class="badge badge-important">Important</span>
				</h3>
				<p class="schema-purpose">
          Customer reviews for products. A customer can write at most one review per product,
          and only if they have purchased that product (i.e., have a delivered order containing it).
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">user_id</span>
								</td>
								<td>UUID (FK ‚Üí users.id)</td>
								<td>Not Null</td>
								<td>The customer who wrote the review.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">product_id</span>
								</td>
								<td>UUID (FK ‚Üí products.id)</td>
								<td>Not Null</td>
								<td>The product being reviewed.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">rating</span>
								</td>
								<td>Integer</td>
								<td>Not Null, Check: 1 ‚â§ rating ‚â§ 5</td>
								<td>Star rating from 1 to 5.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">comment</span>
								</td>
								<td>Text</td>
								<td>Nullable</td>
								<td>Optional text review body.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-constraints">
					<h4>Special Constraints</h4>
					<ul>
						<li>
							<strong>Unique Together:</strong>
							<span class="mono">(user_id, product_id)</span> ‚Äî one review per customer per product. Enforce as a database unique constraint.</li>
					</ul>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">users</span> ‚Äî written by one customer</li>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">products</span> ‚Äî reviews one product</li>
					</ul>
				</div>
			</div>
			<!-- ===== TABLE: addresses ===== -->
			<div class="schema-card" id="schema-addresses">
				<h3 class="schema-title">
					<span class="schema-icon">üìç</span>
          addresses
          <span class="badge badge-important">Important</span>
				</h3>
				<p class="schema-purpose">
          Delivery addresses saved by customers. A customer can have multiple addresses and mark
          one as default. Addresses are referenced by orders for shipping.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">user_id</span>
								</td>
								<td>UUID (FK ‚Üí users.id)</td>
								<td>Not Null, Indexed</td>
								<td>The user who owns this address.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">label</span>
								</td>
								<td>String(50)</td>
								<td>Not Null</td>
								<td>Friendly name like "Home", "Office", "Parents' House".</td>
							</tr>
							<tr>
								<td>
									<span class="mono">address_line_1</span>
								</td>
								<td>String(255)</td>
								<td>Not Null</td>
								<td>Street address, first line.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">address_line_2</span>
								</td>
								<td>String(255)</td>
								<td>Nullable</td>
								<td>Apartment, suite, floor, etc.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">city</span>
								</td>
								<td>String(100)</td>
								<td>Not Null</td>
								<td>City name.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">state</span>
								</td>
								<td>String(100)</td>
								<td>Not Null</td>
								<td>State or province.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">postal_code</span>
								</td>
								<td>String(20)</td>
								<td>Not Null</td>
								<td>ZIP or postal code. String type to support international formats.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">country</span>
								</td>
								<td>String(50)</td>
								<td>Not Null</td>
								<td>Country name or ISO code.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">is_default</span>
								</td>
								<td>Boolean</td>
								<td>Not Null, Default: False</td>
								<td>Only one address per user should be default. Enforce in business logic.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">users</span> ‚Äî belongs to one user</li>
						<li>
							<strong>One-to-Many</strong> with <span class="mono">orders</span> ‚Äî can be used as shipping address for multiple orders</li>
					</ul>
				</div>
			</div>
			<!-- ===== TABLE: cart_items ===== -->
			<div class="schema-card" id="schema-cart-items">
				<h3 class="schema-title">
					<span class="schema-icon">üõí</span>
          cart_items
          <span class="badge badge-core">Core</span>
				</h3>
				<p class="schema-purpose">
          Represents items in a customer's shopping cart. There is no separate "cart" entity ‚Äî the
          cart is implicitly the collection of <span class="mono">cart_items</span> rows for a given
          user. This simplifies the data model significantly.
        </p>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Column</th>
								<th>Type</th>
								<th>Constraints</th>
								<th>Notes</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">user_id</span>
								</td>
								<td>UUID (FK ‚Üí users.id)</td>
								<td>Not Null, Indexed</td>
								<td>The customer whose cart this item belongs to.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">product_id</span>
								</td>
								<td>UUID (FK ‚Üí products.id)</td>
								<td>Not Null</td>
								<td>The product in the cart.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">quantity</span>
								</td>
								<td>Integer</td>
								<td>Not Null, Default: 1, Check: quantity &gt; 0</td>
								<td>How many units the customer wants.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="schema-constraints">
					<h4>Special Constraints</h4>
					<ul>
						<li>
							<strong>Unique Together:</strong>
							<span class="mono">(user_id, product_id)</span> ‚Äî a product appears in the cart at most once. If the customer adds the same product again, increment the quantity instead of creating a duplicate row.</li>
					</ul>
				</div>
				<div class="schema-relationships">
					<h4>Relationships</h4>
					<ul>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">users</span> ‚Äî belongs to one user's cart</li>
						<li>
							<strong>Many-to-One</strong> with <span class="mono">products</span> ‚Äî references one product</li>
					</ul>
				</div>
			</div>
			<!-- Schema Diagram Summary -->
			<h3 id="s3-diagram">3.1 Relationship Summary</h3>
			<p>
        Here is a quick-reference table showing all foreign key relationships at a glance. Use this to
        verify your SQLAlchemy relationship definitions are complete.
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>From Table</th>
							<th>Column</th>
							<th>To Table</th>
							<th>Relationship Type</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>stores</td>
							<td>owner_id</td>
							<td>users</td>
							<td>Many-to-One (unique = One-to-One)</td>
						</tr>
						<tr>
							<td>products</td>
							<td>store_id</td>
							<td>stores</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>products</td>
							<td>category_id</td>
							<td>categories</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>product_images</td>
							<td>product_id</td>
							<td>products</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>orders</td>
							<td>user_id</td>
							<td>users</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>orders</td>
							<td>shipping_address_id</td>
							<td>addresses</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>order_items</td>
							<td>order_id</td>
							<td>orders</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>order_items</td>
							<td>product_id</td>
							<td>products</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>order_items</td>
							<td>store_id</td>
							<td>stores</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>reviews</td>
							<td>user_id</td>
							<td>users</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>reviews</td>
							<td>product_id</td>
							<td>products</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>addresses</td>
							<td>user_id</td>
							<td>users</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>cart_items</td>
							<td>user_id</td>
							<td>users</td>
							<td>Many-to-One</td>
						</tr>
						<tr>
							<td>cart_items</td>
							<td>product_id</td>
							<td>products</td>
							<td>Many-to-One</td>
						</tr>
					</tbody>
				</table>
			</div>
			<!-- Optional Extensions -->
			<h3 id="s3-optional">3.2 Optional Extension Tables</h3>
			<div class="callout callout-info">
				<div class="callout-header">üí° Not Required for Core Learning</div>
				<p>
          The following tables are <strong>not</strong> part of the core project. They are mentioned here
          as ideas for extending the project after you complete all 17 phases. Each one would teach
          additional database patterns but is not necessary for learning FastAPI fundamentals.
        </p>
			</div>
			<ul>
				<li>
					<strong>wishlists / wishlist_items</strong> ‚Äî simple many-to-many between users and products. Teaches junction table patterns.</li>
				<li>
					<strong>coupons</strong> ‚Äî discount codes with expiry dates and usage limits. Teaches complex validation logic.</li>
				<li>
					<strong>notifications</strong> ‚Äî in-app notification storage. Teaches polymorphic patterns and read/unread tracking.</li>
				<li>
					<strong>payment_records</strong> ‚Äî simulated payment tracking. Teaches state machines and external service integration patterns.</li>
			</ul>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 4 ‚Äî API ENDPOINT SPECIFICATION                      -->
		<!-- =========================================================== -->
		<section id="section-4" class="content-section">
			<div class="section-header">
				<span class="section-number">04</span>
				<h2 class="section-title">API Endpoint Specification</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>Every API endpoint in the marketplace, grouped by feature domain</li>
					<li>The HTTP method, URL path, and purpose of each endpoint</li>
					<li>Who is authorized to call each endpoint</li>
					<li>Key request and response fields described in plain English</li>
					<li>Important validation rules and business logic for each endpoint</li>
					<li>Which FastAPI concept each endpoint primarily demonstrates</li>
				</ul>
			</div>
			<p>
        This section is your API blueprint. Before building each phase, read the endpoint specifications
        below to understand exactly what you need to implement. Endpoints are grouped by feature domain
        and ordered to match the implementation phases.
      </p>
			<!-- ===== AUTH ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-auth">
				<h3 class="endpoint-group-title">üîê Authentication Endpoints</h3>
				<p class="endpoint-group-desc">
          Handle user registration, login, and token management. These are the first endpoints
          you will build (Phases 2‚Äì3).
        </p>
				<!-- POST /auth/register -->
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/auth/register</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Register a new user account on the platform.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public ‚Äî no authentication required</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">email</span> (valid email, required), <span class="mono">password</span> (minimum 8 characters, required), <span class="mono">full_name</span> (string, required), <span class="mono">role</span> (one of "customer" or "vendor", optional ‚Äî defaults to "customer")</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (201):</strong>
							<span>User object with <span class="mono">id</span>, <span class="mono">email</span>, <span class="mono">full_name</span>, <span class="mono">role</span>, <span class="mono">is_active</span>, <span class="mono">created_at</span>. Never include password in response.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>Email must be unique ‚Äî return 409 Conflict if already registered</li>
								<li>Password must meet minimum length requirement</li>
								<li>Users cannot self-register as admin ‚Äî admin accounts are created by other admins or via seeding</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Pydantic request/response models, status code override, password hashing in service layer</span>
						</div>
					</div>
				</div>
				<!-- POST /auth/login -->
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/auth/login</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Authenticate a user and receive JWT tokens.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public ‚Äî no authentication required</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">email</span> (required), <span class="mono">password</span> (required). Alternatively, use FastAPI's <span class="mono">OAuth2PasswordRequestForm</span> which expects <span class="mono">username</span> and <span class="mono">password</span> as form data.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>
								<span class="mono">access_token</span> (JWT string), <span class="mono">refresh_token</span> (JWT string), <span class="mono">token_type</span> ("bearer"), <span class="mono">user</span> (user object with id, email, role)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>Verify email exists and password matches the stored hash</li>
								<li>Return 401 with a generic "Invalid credentials" message ‚Äî never reveal whether the email or password was wrong</li>
								<li>Check that the user account is active ‚Äî return 403 if deactivated</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>
								<span class="mono">OAuth2PasswordBearer</span>, <span class="mono">OAuth2PasswordRequestForm</span>, JWT token generation, security utilities</span>
						</div>
					</div>
				</div>
				<!-- POST /auth/refresh -->
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/auth/refresh</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Exchange a valid refresh token for a new access token.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Requires a valid refresh token in the request body</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">refresh_token</span> (JWT string, required)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>New <span class="mono">access_token</span> and <span class="mono">token_type</span>
							</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>Validate the refresh token signature and expiration</li>
								<li>Verify the token type claim is "refresh" (not "access")</li>
								<li>Verify the user still exists and is active</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>JWT decoding and validation, token type differentiation, conditional error handling</span>
						</div>
					</div>
				</div>
				<!-- GET /auth/me -->
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/auth/me</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Get the currently authenticated user's profile information.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Full user profile object including <span class="mono">id</span>, <span class="mono">email</span>, <span class="mono">full_name</span>, <span class="mono">role</span>, <span class="mono">phone</span>, <span class="mono">is_active</span>, <span class="mono">created_at</span>
							</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>
								<span class="mono">Depends(get_current_user)</span> ‚Äî the first protected endpoint you build. Demonstrates the core dependency injection auth pattern.</span>
						</div>
					</div>
				</div>
				<!-- PUT /auth/me -->
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-put">PUT</span>
						<span class="endpoint-path">/api/v1/auth/me</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Update the current user's profile information.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">full_name</span> (optional), <span class="mono">phone</span> (optional). Users cannot change their own role or email through this endpoint.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Updated user profile object</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Partial update with optional Pydantic fields, restricting which fields are updatable</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== STORE ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-stores">
				<h3 class="endpoint-group-title">üè™ Store Management Endpoints</h3>
				<p class="endpoint-group-desc">
          Vendor store CRUD operations (Phase 4). Vendors manage their own store; admins can activate/deactivate.
        </p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/stores</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Create a new store for the authenticated vendor.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Vendor only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">name</span> (unique string, required), <span class="mono">description</span> (string, optional)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (201):</strong>
							<span>Created store object with <span class="mono">id</span>, <span class="mono">name</span>, <span class="mono">description</span>, <span class="mono">is_active</span>, <span class="mono">owner_id</span>
							</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>User must have "vendor" role ‚Äî return 403 otherwise</li>
								<li>Vendor must not already have a store ‚Äî return 409 Conflict if they do</li>
								<li>Store name must be unique across the platform</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Role-checking dependency, conflict detection, <span class="mono">status_code=201</span> on route decorator</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/stores</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">List all active stores with pagination.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Query Parameters:</strong>
							<span>
								<span class="mono">page</span> (default 1), <span class="mono">size</span> (default 20, max 100)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Paginated list of store objects (active stores only for public; admin sees all)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Query parameters with defaults and validation, pagination pattern</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/stores/{store_id}</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Get a single store's public profile by its ID.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Store object with owner info and product count</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Return 404 if store does not exist or is inactive</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Path parameters with UUID type, 404 handling</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-put">PUT</span>
						<span class="endpoint-path">/api/v1/stores/{store_id}</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Update a store's details. Only the store owner can do this.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Store owner (vendor) only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">name</span> (optional), <span class="mono">description</span> (optional)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>Verify the authenticated user is the store owner ‚Äî return 403 otherwise</li>
								<li>If changing name, verify uniqueness</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Ownership verification pattern, combining auth + resource check dependencies</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-patch">PATCH</span>
						<span class="endpoint-path">/api/v1/stores/{store_id}/status</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Activate or deactivate a store. Admin only.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Admin only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">is_active</span> (boolean, required)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Admin-only dependency guard, PATCH for partial updates</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== CATEGORY ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-categories">
				<h3 class="endpoint-group-title">üè∑Ô∏è Category Endpoints</h3>
				<p class="endpoint-group-desc">
          Category CRUD managed by admins (Phase 5). Categories are read publicly by anyone.
        </p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/categories</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Create a new product category.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Admin only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">name</span> (unique, required), <span class="mono">description</span> (optional)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (201):</strong>
							<span>Category object. The <span class="mono">slug</span> is auto-generated from the name in the service layer.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Admin dependency, auto-generating derived fields in the service layer</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/categories</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">List all active categories.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>List of category objects. No pagination needed ‚Äî categories are few in number. This is a good candidate for Redis caching in Phase 13.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Simple list endpoint, response model with <span class="mono">List[CategorySchema]</span>
							</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-put">PUT</span>
						<span class="endpoint-path">/api/v1/categories/{category_id}</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Update an existing category's name or description.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Admin only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Regenerate slug if name changes. Ensure new name is unique.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Path parameter validation, update pattern, cache invalidation (Phase 13)</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-delete">DELETE</span>
						<span class="endpoint-path">/api/v1/categories/{category_id}</span>
						<span class="badge badge-optional">Optional Extension</span>
					</div>
					<p class="endpoint-purpose">Delete a category, only if no products are assigned to it.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Admin only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response:</strong>
							<span>204 No Content on success</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Check that no products reference this category ‚Äî return 400 if any do</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>
								<span class="mono">status_code=204</span>, referential integrity check before deletion</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== PRODUCT ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-products">
				<h3 class="endpoint-group-title">üì¶ Product Endpoints</h3>
				<p class="endpoint-group-desc">
          Product CRUD with search, filtering, and pagination (Phase 6). The most feature-rich
          endpoint group that demonstrates advanced query patterns.
        </p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/products</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Create a new product in the vendor's store.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Vendor only (must have an active store)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">name</span> (required), <span class="mono">description</span> (optional), <span class="mono">price</span> (positive decimal, required), <span class="mono">stock</span> (non-negative integer, required), <span class="mono">category_id</span> (valid UUID, required)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>Vendor must have an active store</li>
								<li>Category must exist and be active</li>
								<li>Price must be greater than zero</li>
								<li>Product is automatically assigned to the vendor's store</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Cross-entity validation in service layer, auto-populating <span class="mono">store_id</span> from authenticated user context</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/products</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">List products with pagination, filtering, search, and sorting.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Query Parameters:</strong>
							<ul>
								<li>
									<span class="mono">page</span> (integer, default 1) ‚Äî page number</li>
								<li>
									<span class="mono">size</span> (integer, default 20, max 100) ‚Äî items per page</li>
								<li>
									<span class="mono">category_id</span> (UUID, optional) ‚Äî filter by category</li>
								<li>
									<span class="mono">store_id</span> (UUID, optional) ‚Äî filter by store</li>
								<li>
									<span class="mono">min_price</span> (decimal, optional) ‚Äî minimum price filter</li>
								<li>
									<span class="mono">max_price</span> (decimal, optional) ‚Äî maximum price filter</li>
								<li>
									<span class="mono">search</span> (string, optional) ‚Äî search in name and description</li>
								<li>
									<span class="mono">sort_by</span> (string, optional, default "created_at") ‚Äî sort field (price, name, created_at)</li>
								<li>
									<span class="mono">sort_order</span> (string, optional, default "desc") ‚Äî "asc" or "desc"</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Paginated envelope with <span class="mono">items</span>, <span class="mono">total</span>, <span class="mono">page</span>, <span class="mono">size</span>, <span class="mono">pages</span>
							</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Multiple query parameters, building dynamic SQLAlchemy queries, pagination helper, <span class="mono">Query()</span> with validation constraints (ge, le, max_length)</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/products/{product_id}</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Get detailed information about a single product.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Product object with nested store info, category info, images list, and average rating</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Nested response models, eager loading relationships with SQLAlchemy, computed/aggregated fields</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-put">PUT</span>
						<span class="endpoint-path">/api/v1/products/{product_id}</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Update a product's details. Only the product's store owner can do this.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Vendor (store owner) only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>Same fields as create, all optional for partial update</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Verify the authenticated vendor owns the store that this product belongs to. If changing category, verify new category exists.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Ownership chain verification (user ‚Üí store ‚Üí product), partial update pattern with optional fields</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-delete">DELETE</span>
						<span class="endpoint-path">/api/v1/products/{product_id}</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Soft-delete a product by setting <span class="mono">is_active</span> to false.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Vendor (store owner) only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response:</strong>
							<span>204 No Content</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Ownership verification. Product remains in the database for order history integrity but is excluded from search and browse.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Soft delete pattern, 204 response with no body</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== FILE UPLOAD ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-uploads">
				<h3 class="endpoint-group-title">üñºÔ∏è Product Image Endpoints</h3>
				<p class="endpoint-group-desc">File upload handling for product images (Phase 7).</p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/products/{product_id}/images</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Upload an image for a product.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Vendor (product owner) only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request:</strong>
							<span>Multipart form data with <span class="mono">file</span> (image file) and optional <span class="mono">is_primary</span> (boolean)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>File must be an image type (JPEG, PNG, WebP)</li>
								<li>File size must not exceed a configurable limit (e.g., 5 MB)</li>
								<li>Maximum number of images per product (e.g., 5)</li>
								<li>If marked as primary, unmark any existing primary image</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>
								<span class="mono">UploadFile</span>, <span class="mono">File()</span>, <span class="mono">Form()</span>, file content type validation, saving files to disk</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-delete">DELETE</span>
						<span class="endpoint-path">/api/v1/products/{product_id}/images/{image_id}</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Delete a product image.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Vendor (product owner) only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response:</strong>
							<span>204 No Content</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Verify ownership chain. Delete both the database record and the file from disk.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Multiple path parameters, file system cleanup, transactional operations (delete file only if DB delete succeeds)</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== CART ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-cart">
				<h3 class="endpoint-group-title">üõí Cart Endpoints</h3>
				<p class="endpoint-group-desc">Shopping cart management for customers (Phase 8).</p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/cart</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">View the current user's shopping cart with all items, product details, and totals.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>List of cart items, each including product name, price, quantity, line subtotal, and a computed <span class="mono">cart_total</span>
							</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Computed/derived fields in response model, joining across tables, nested Pydantic models</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/cart/items</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Add a product to the cart or increment its quantity if already present.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">product_id</span> (UUID, required), <span class="mono">quantity</span> (integer, default 1)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>Product must exist and be active</li>
								<li>Requested quantity must not exceed available stock</li>
								<li>If product is already in cart, add to existing quantity (do not create duplicate)</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Upsert pattern (insert or update), stock validation, idempotent-like behavior</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-put">PUT</span>
						<span class="endpoint-path">/api/v1/cart/items/{product_id}</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Update the quantity of a specific item in the cart.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">quantity</span> (positive integer, required)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Product must be in the user's cart. New quantity must not exceed available stock. If quantity is set to zero, remove the item.</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-delete">DELETE</span>
						<span class="endpoint-path">/api/v1/cart/items/{product_id}</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Remove a specific item from the cart.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response:</strong>
							<span>204 No Content</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-delete">DELETE</span>
						<span class="endpoint-path">/api/v1/cart</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Clear the entire cart (remove all items).</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response:</strong>
							<span>204 No Content</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Bulk delete operation, same path different method (GET vs DELETE on <span class="mono">/cart</span>)</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== ORDER ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-orders">
				<h3 class="endpoint-group-title">üìã Order Endpoints</h3>
				<p class="endpoint-group-desc">Order placement and management (Phase 9). Involves multi-table transactions and status workflows.</p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/orders</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Place a new order from the current contents of the user's cart.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">shipping_address_id</span> (UUID, required)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Business Logic (all in service layer):</strong>
							<ol>
								<li>Verify the cart is not empty ‚Äî return 400 if it is</li>
								<li>Verify the shipping address belongs to the current user</li>
								<li>For each cart item: verify the product is still active and has sufficient stock</li>
								<li>Generate a unique order number</li>
								<li>Create the order record with total amount (sum of all item subtotals)</li>
								<li>Create order item records, snapshotting the current price</li>
								<li>Decrement product stock for each item</li>
								<li>Clear the user's cart</li>
								<li>All of the above must happen in a single database transaction ‚Äî if any step fails, everything rolls back</li>
							</ol>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Database transactions, multi-step business operations, transactional integrity, background task trigger (order confirmation)</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/me/orders</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">List the current user's order history with pagination.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Query Parameters:</strong>
							<span>
								<span class="mono">page</span>, <span class="mono">size</span>, optional <span class="mono">status</span> filter</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Paginated list of orders with basic info (order number, status, total, date). Does not include full item details.</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/me/orders/{order_id}</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Get detailed information about a specific order, including all line items.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Order owner only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Full order object with nested order items (product name, quantity, unit price, subtotal, item status), shipping address, and order totals</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Verify the order belongs to the authenticated user ‚Äî return 404 if it does not (not 403, to avoid revealing the order exists)</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/vendor/orders</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">List order items for products belonging to the vendor's store.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Vendor only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Paginated list of order items where <span class="mono">store_id</span> matches the vendor's store. Includes order number, customer name (not email), product name, quantity, and item status.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Filtering by related entity, vendor-specific view of shared data</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-patch">PATCH</span>
						<span class="endpoint-path">/api/v1/vendor/orders/{order_item_id}/status</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Update the status of an order item. Vendors can only update items from their own store.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Vendor (item's store owner) only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">status</span> (string, one of the valid next statuses)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Enforce valid status transitions. Vendor can only modify their own order items. Optionally update the parent order status if all items reach the same status.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>State machine validation, PATCH semantics, cross-entity updates</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== REVIEW ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-reviews">
				<h3 class="endpoint-group-title">‚≠ê Review Endpoints</h3>
				<p class="endpoint-group-desc">Product review system (Phase 10).</p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/products/{product_id}/reviews</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Write a review for a product the customer has purchased.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>
								<span class="mono">rating</span> (integer 1-5, required), <span class="mono">comment</span> (string, optional)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<ul>
								<li>User must have a delivered order containing this product</li>
								<li>User must not have already reviewed this product (unique constraint)</li>
								<li>Rating must be between 1 and 5</li>
							</ul>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Complex cross-table validation in service layer, unique constraint handling, nested route (<span class="mono">/products/{id}/reviews</span>)</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/products/{product_id}/reviews</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">List all reviews for a specific product with pagination.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Paginated list of reviews with reviewer name (not email), rating, comment, and date. Include average rating and total review count in the response metadata.</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Aggregate queries (AVG, COUNT), metadata alongside paginated data</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== ADDRESS ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-addresses">
				<h3 class="endpoint-group-title">üìç Address Endpoints</h3>
				<p class="endpoint-group-desc">Customer delivery address management (Phase 11).</p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-post">POST</span>
						<span class="endpoint-path">/api/v1/me/addresses</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Add a new delivery address for the current user.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Request Body:</strong>
							<span>All address fields (label, address lines, city, state, postal code, country, is_default)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>If <span class="mono">is_default</span> is true, set all other addresses for this user to non-default first. If this is the user's first address, automatically set it as default.</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/me/addresses</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">List all addresses for the current user.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Any authenticated user</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>List of address objects. Default address first.</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-put">PUT</span>
						<span class="endpoint-path">/api/v1/me/addresses/{address_id}</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Update an existing address.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Address owner only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Address must belong to the authenticated user. Handle default flag changes.</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-delete">DELETE</span>
						<span class="endpoint-path">/api/v1/me/addresses/{address_id}</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Delete an address.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Address owner only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Key Validations:</strong>
							<span>Cannot delete an address that is referenced by existing orders. If deleting the default address, promote another address to default if any remain.</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== ADMIN ENDPOINTS ===== -->
			<div class="endpoint-group" id="ep-admin">
				<h3 class="endpoint-group-title">üõ°Ô∏è Admin Endpoints</h3>
				<p class="endpoint-group-desc">Platform administration endpoints.</p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/admin/stats</span>
						<span class="badge badge-important">Important</span>
					</div>
					<p class="endpoint-purpose">Get basic platform statistics.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Admin only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>Total users, total vendors, total stores, total products, total orders, total revenue (sum of all order totals)</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Aggregate queries, admin-only dependency, multiple COUNT/SUM queries</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/admin/users</span>
						<span class="badge badge-optional">Optional Extension</span>
					</div>
					<p class="endpoint-purpose">List all users with pagination and optional role filter.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Admin only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Query Parameters:</strong>
							<span>
								<span class="mono">page</span>, <span class="mono">size</span>, <span class="mono">role</span> (optional filter)</span>
						</div>
					</div>
				</div>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/admin/orders</span>
						<span class="badge badge-optional">Optional Extension</span>
					</div>
					<p class="endpoint-purpose">List all orders across the platform with pagination and filters.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Admin only</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Query Parameters:</strong>
							<span>
								<span class="mono">page</span>, <span class="mono">size</span>, <span class="mono">status</span> (optional), <span class="mono">user_id</span> (optional)</span>
						</div>
					</div>
				</div>
			</div>
			<!-- ===== HEALTH CHECK ===== -->
			<div class="endpoint-group" id="ep-health">
				<h3 class="endpoint-group-title">üíö Health Check</h3>
				<p class="endpoint-group-desc">Operational readiness endpoint.</p>
				<div class="endpoint-card">
					<div class="endpoint-header">
						<span class="http-method method-get">GET</span>
						<span class="endpoint-path">/api/v1/health</span>
						<span class="badge badge-core">Core</span>
					</div>
					<p class="endpoint-purpose">Simple health check to verify the API and its dependencies are running.</p>
					<div class="endpoint-details">
						<div class="endpoint-detail-row">
							<strong>Access:</strong>
							<span>Public</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>Response (200):</strong>
							<span>
								<span class="mono">status</span> ("healthy"), <span class="mono">database</span> ("connected" or "error"), <span class="mono">redis</span> ("connected" or "error"), <span class="mono">timestamp</span>
							</span>
						</div>
						<div class="endpoint-detail-row">
							<strong>FastAPI Concepts:</strong>
							<span>Simple endpoint, dependency health checking, try/except around infrastructure calls</span>
						</div>
					</div>
				</div>
			</div>
			<!-- Endpoint Count Summary -->
			<h3 id="s4-summary">4.1 Endpoint Summary</h3>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Domain</th>
							<th>Endpoints</th>
							<th>Phase</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Authentication</td>
							<td>5</td>
							<td>2‚Äì3</td>
						</tr>
						<tr>
							<td>Stores</td>
							<td>5</td>
							<td>4</td>
						</tr>
						<tr>
							<td>Categories</td>
							<td>4</td>
							<td>5</td>
						</tr>
						<tr>
							<td>Products</td>
							<td>5</td>
							<td>6</td>
						</tr>
						<tr>
							<td>Product Images</td>
							<td>2</td>
							<td>7</td>
						</tr>
						<tr>
							<td>Cart</td>
							<td>5</td>
							<td>8</td>
						</tr>
						<tr>
							<td>Orders</td>
							<td>5</td>
							<td>9</td>
						</tr>
						<tr>
							<td>Reviews</td>
							<td>2</td>
							<td>10</td>
						</tr>
						<tr>
							<td>Addresses</td>
							<td>4</td>
							<td>11</td>
						</tr>
						<tr>
							<td>Admin</td>
							<td>3</td>
							<td>Various</td>
						</tr>
						<tr>
							<td>Health</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>
								<strong>Total</strong>
							</td>
							<td>
								<strong>41</strong>
							</td>
							<td></td>
						</tr>
					</tbody>
				</table>
			</div>
			<div class="callout callout-info">
				<div class="callout-header">üí° Why 41 Endpoints Is Enough</div>
				<p>
          Forty-one endpoints cover every fundamental CRUD pattern, authentication flow, file upload
          mechanism, pagination approach, and business logic pattern you need to learn. A real marketplace
          might have hundreds, but each additional endpoint would largely repeat patterns you have already
          mastered. Quality of understanding beats quantity of endpoints.
        </p>
			</div>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 5 ‚Äî PHASE-BY-PHASE IMPLEMENTATION GUIDE             -->
		<!-- =========================================================== -->
		<section id="section-5" class="content-section">
			<div class="section-header">
				<span class="section-number">05</span>
				<h2 class="section-title">Phase-by-Phase Implementation Guide</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ How to Use This Section</div>
				<ul>
					<li>Each phase is a self-contained <strong>learning module</strong> ‚Äî complete them in order</li>
					<li>Every phase lists <strong>learning objectives</strong>, files to create, step-by-step approach, key concepts, tests, and common mistakes</li>
					<li>Use the <strong>checkpoint</strong> at the end of each phase to verify your work before moving on</li>
					<li>Do not skip ahead ‚Äî later phases build on patterns established in earlier ones</li>
					<li>Take your time understanding <strong>why</strong> things work, not just making them run</li>
				</ul>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 1 ‚Äî PROJECT SETUP                                     -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-1">
				<div class="phase-header">
					<div class="phase-number">Phase 1</div>
					<h3 class="phase-title">Project Setup, Structure &amp; Database Connection</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Understand FastAPI application factory pattern and how the app starts</li>
						<li>Learn Pydantic <span class="mono">BaseSettings</span> for environment-based configuration</li>
						<li>Set up async SQLAlchemy with PostgreSQL</li>
						<li>Create the database session dependency (<span class="mono">get_db</span>)</li>
						<li>Understand the project folder structure and why it is organized that way</li>
						<li>Set up Alembic for database migrations</li>
						<li>Build your first endpoint (health check)</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          The foundational skeleton of the application. After this phase, you should have a running
          FastAPI application that connects to PostgreSQL, responds to a health check endpoint, and
          is ready to receive feature modules in subsequent phases. No business features yet ‚Äî just
          solid infrastructure.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/main.py</span>
								</td>
								<td>Application entry point. Creates the FastAPI app, includes routers, registers middleware and exception handlers.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/config.py</span>
								</td>
								<td>Pydantic <span class="mono">BaseSettings</span> class. Loads and validates all environment variables.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/database.py</span>
								</td>
								<td>Async SQLAlchemy engine, session factory, and the <span class="mono">get_db</span> dependency (an async generator).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/models/base.py</span>
								</td>
								<td>SQLAlchemy declarative base with shared columns (id, created_at, updated_at).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/health.py</span>
								</td>
								<td>Health check endpoint.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/exceptions.py</span>
								</td>
								<td>Custom exception classes and FastAPI exception handlers.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">alembic.ini</span>
								</td>
								<td>Alembic configuration file.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">alembic/env.py</span>
								</td>
								<td>Alembic migration environment ‚Äî connects to the database and imports models.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">.env</span>
								</td>
								<td>Environment variables for local development (never commit to git).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">.env.example</span>
								</td>
								<td>Template showing required environment variables (committed to git, no real values).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">requirements.txt</span>
								</td>
								<td>Python dependencies.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">.gitignore</span>
								</td>
								<td>Files and directories to exclude from version control.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Create the project directory structure.</strong> Follow the structure described in
            Section 6. Create all the necessary directories and empty <span class="mono">__init__.py</span>
            files to make them Python packages.
          </li>
					<li>
						<strong>Set up a virtual environment and install dependencies.</strong> You need FastAPI,
            Uvicorn (ASGI server), SQLAlchemy (with async support), asyncpg (async PostgreSQL driver),
            Alembic, Pydantic Settings, and python-dotenv.
          </li>
					<li>
						<strong>Create the configuration module.</strong> Define a <span class="mono">Settings</span>
            class extending Pydantic <span class="mono">BaseSettings</span>. Add fields for
            DATABASE_URL, SECRET_KEY, DEBUG, and other values listed in Section 2.4. Configure the
            class to read from a <span class="mono">.env</span> file. Create a function that returns a
            cached settings instance.
          </li>
					<li>
						<strong>Set up the database connection.</strong> Create an async SQLAlchemy engine using
            <span class="mono">create_async_engine</span> with the DATABASE_URL from settings. Create
            an async session factory using <span class="mono">async_sessionmaker</span>. Write the
            <span class="mono">get_db</span> async generator dependency that yields a session and
            ensures it is closed after the request.
          </li>
					<li>
						<strong>Create the base model.</strong> Define a declarative base class with
            <span class="mono">id</span> (UUID primary key with a default factory),
            <span class="mono">created_at</span> (server default to current timestamp), and
            <span class="mono">updated_at</span> (auto-updated on modification). All future models
            will inherit from this base.
          </li>
					<li>
						<strong>Create custom exception classes.</strong> Define the five exceptions from Section 2.7.
            Each stores a <span class="mono">detail</span> message and an <span class="mono">error_code</span>.
            Register exception handlers on the FastAPI app that catch these exceptions and return the
            correct HTTP status code with a consistent JSON body.
          </li>
					<li>
						<strong>Create the FastAPI application instance.</strong> In <span class="mono">main.py</span>,
            create the app with a title, description, and version. Add a lifespan handler (or startup/shutdown
            events) if needed. Include the health check router. Register the exception handlers.
          </li>
					<li>
						<strong>Build the health check endpoint.</strong> A simple GET endpoint at
            <span class="mono">/api/v1/health</span> that checks database connectivity (try running a
            simple query), checks Redis connectivity (you can add this later in Phase 13), and returns
            a status JSON.
          </li>
					<li>
						<strong>Initialize Alembic.</strong> Run <span class="mono">alembic init alembic</span>.
            Edit <span class="mono">alembic/env.py</span> to import your Base model's metadata and
            read the database URL from your settings. Edit <span class="mono">alembic.ini</span> to
            remove the hardcoded database URL (it should come from the environment).
          </li>
					<li>
						<strong>Start the application and verify.</strong> Run Uvicorn, navigate to
            <span class="mono">/docs</span> (Swagger UI), and confirm the health check endpoint works.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Application Factory</h5>
						<p>
              The pattern of creating the FastAPI app in a function (or module) rather than at import
              time. This allows you to configure the app differently for testing vs. production.
              Even if you start with a simple module-level <span class="mono">app = FastAPI()</span>,
              understand that production apps often wrap this in a factory function.
            </p>
					</div>
					<div class="concept-card">
						<h5>Async Database Sessions</h5>
						<p>
              FastAPI is async-first. Using <span class="mono">create_async_engine</span> and
              <span class="mono">AsyncSession</span> means database operations do not block the event
              loop. The <span class="mono">get_db</span> dependency uses <span class="mono">async with</span>
              or an async generator to ensure sessions are properly opened and closed per request.
              This is the <strong>most critical dependency</strong> in your entire application.
            </p>
					</div>
					<div class="concept-card">
						<h5>Pydantic BaseSettings</h5>
						<p>
              Unlike regular Pydantic models that validate arbitrary data, <span class="mono">BaseSettings</span>
              reads values from environment variables (and optionally <span class="mono">.env</span> files).
              It gives you type validation, default values, and automatic casting ‚Äî all at startup time.
              A missing required setting crashes the app immediately with a clear error, not silently
              at runtime.
            </p>
					</div>
					<div class="concept-card">
						<h5>Alembic Migrations</h5>
						<p>
              Alembic tracks database schema changes as sequential migration files. Instead of manually
              altering tables, you generate migrations from your SQLAlchemy models. This ensures your
              database schema is version-controlled and reproducible. The key commands are
              <span class="mono">alembic revision --autogenerate</span> (create a migration) and
              <span class="mono">alembic upgrade head</span> (apply all pending migrations).
            </p>
					</div>
				</div>
				<h4>Testing This Phase</h4>
				<ul>
					<li>The application starts without errors when you run Uvicorn</li>
					<li>The Swagger UI is accessible at <span class="mono">/docs</span>
					</li>
					<li>The health check endpoint returns a 200 response with database status</li>
					<li>An Alembic migration can be generated (even if no tables exist yet, it should produce an empty migration)</li>
					<li>Changing an environment variable in <span class="mono">.env</span> correctly updates the app behavior</li>
				</ul>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Using a synchronous database driver.</strong> Make sure you install <span class="mono">asyncpg</span> (not <span class="mono">psycopg2</span>) and use <span class="mono">create_async_engine</span> (not <span class="mono">create_engine</span>). The database URL should start with <span class="mono">postgresql+asyncpg://</span>.</li>
						<li>
							<strong>Forgetting to close the session.</strong> The <span class="mono">get_db</span> dependency must use <span class="mono">try/finally</span> or an async context manager to ensure the session is closed, even if an exception occurs.</li>
						<li>
							<strong>Hardcoding configuration values.</strong> Never put database URLs, secret keys, or any credentials directly in your Python files. Always use environment variables via Pydantic Settings.</li>
						<li>
							<strong>Committing <span class="mono">.env</span> to git.</strong> Add it to <span class="mono">.gitignore</span> immediately. Commit <span class="mono">.env.example</span> instead.</li>
						<li>
							<strong>Not setting up Alembic to read from the same settings.</strong> If Alembic uses a different database URL than your app, migrations will target the wrong database.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Running <span class="mono">uvicorn app.main:app --reload</span> starts the server successfully</li>
						<li>
							<span class="mono">GET /api/v1/health</span> returns <span class="mono">{"status": "healthy", "database": "connected"}</span>
						</li>
						<li>Swagger UI at <span class="mono">/docs</span> shows the health endpoint</li>
						<li>Your project structure matches the layout in Section 6</li>
						<li>All configuration comes from environment variables, no hardcoded values</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 2 ‚Äî AUTH: REGISTRATION & LOGIN                        -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-2">
				<div class="phase-header">
					<div class="phase-number">Phase 2</div>
					<h3 class="phase-title">User Registration, Login &amp; JWT Authentication</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Create your first SQLAlchemy model (users table)</li>
						<li>Learn Pydantic schemas for request validation and response serialization</li>
						<li>Understand password hashing with bcrypt</li>
						<li>Generate and validate JWT access and refresh tokens</li>
						<li>Build the layered architecture: Router ‚Üí Service ‚Üí Repository</li>
						<li>Use <span class="mono">OAuth2PasswordBearer</span> and <span class="mono">OAuth2PasswordRequestForm</span>
						</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          The complete user registration and login flow. A user can register with email, password,
          and name. They can then log in to receive JWT tokens. The <span class="mono">/auth/me</span>
          endpoint returns the current user's profile. This phase establishes the layered architecture
          pattern that every subsequent phase will follow.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/user.py</span>
								</td>
								<td>SQLAlchemy User model with columns from the schema section.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/user.py</span>
								</td>
								<td>Pydantic schemas: UserCreate (request), UserResponse (response), UserLogin, TokenResponse.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/repositories/user.py</span>
								</td>
								<td>UserRepository class with methods: get_by_id, get_by_email, create.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/user.py</span>
								</td>
								<td>UserService class with methods: register, authenticate, get_profile.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/auth.py</span>
								</td>
								<td>Auth utilities: hash_password, verify_password, create_access_token, create_refresh_token, decode_token.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/auth.py</span>
								</td>
								<td>Auth router with register, login, refresh, and me endpoints.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/dependencies/auth.py</span>
								</td>
								<td>The <span class="mono">get_current_user</span> dependency function.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Define the User model.</strong> Create the SQLAlchemy model with all columns from the
            <span class="mono">users</span> schema table. Inherit from the Base model you created in Phase 1.
            Use a Python enum class for the role field values.
          </li>
					<li>
						<strong>Generate and run the first migration.</strong> Use Alembic to auto-generate a migration
            for the users table, then apply it to create the table in PostgreSQL. Verify the table exists
            using a database client.
          </li>
					<li>
						<strong>Define Pydantic schemas.</strong> Create separate schemas for different purposes:
            <span class="mono">UserCreate</span> for registration input (with email, password, full_name, role validation),
            <span class="mono">UserResponse</span> for output (without password),
            <span class="mono">TokenResponse</span> for login response. Use Pydantic validators for email format and password length.
          </li>
					<li>
						<strong>Build the repository layer.</strong> Create <span class="mono">UserRepository</span>
            that receives an async database session and provides methods to query and create users.
            Keep it purely data-access ‚Äî no business logic.
          </li>
					<li>
						<strong>Build the auth utilities.</strong> Create functions for password hashing (using
            <span class="mono">passlib</span> with bcrypt), password verification, and JWT token
            creation/decoding (using <span class="mono">python-jose</span> or <span class="mono">PyJWT</span>).
            The access token payload should contain: user ID (<span class="mono">sub</span>), role, token type
            ("access"), and expiration. The refresh token is similar but with a longer expiration and type "refresh".
          </li>
					<li>
						<strong>Build the service layer.</strong> Create <span class="mono">UserService</span> with a
            <span class="mono">register</span> method (checks email uniqueness, hashes password, creates user)
            and an <span class="mono">authenticate</span> method (verifies credentials, returns tokens).
            Raise custom exceptions for duplicate emails, invalid credentials, and inactive accounts.
          </li>
					<li>
						<strong>Build the <span class="mono">get_current_user</span> dependency.</strong> This function
            extracts the Bearer token from the Authorization header (using <span class="mono">OAuth2PasswordBearer</span>),
            decodes it, validates the token type is "access" and it has not expired, loads the user from
            the database by ID, checks the user is active, and returns the user object. If any step fails,
            raise <span class="mono">UnauthorizedException</span>.
          </li>
					<li>
						<strong>Build the auth router.</strong> Create endpoints for register, login, refresh, and me.
            Each endpoint should be a thin function: parse input ‚Üí call service ‚Üí return response. The me
            endpoint uses <span class="mono">Depends(get_current_user)</span> to get the authenticated user.
          </li>
					<li>
						<strong>Register the router in <span class="mono">main.py</span>.</strong> Include the auth
            router with a prefix of <span class="mono">/api/v1/auth</span>.
          </li>
					<li>
						<strong>Test manually via Swagger UI.</strong> Register a user, log in, copy the access token,
            and use it to call the <span class="mono">/auth/me</span> endpoint. Verify error cases: duplicate
            email, wrong password, expired token.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Pydantic Schema Separation</h5>
						<p>
              Never use a single schema for both input and output. The create schema includes a password
              field; the response schema must never include it. This separation prevents accidentally
              leaking sensitive data. You may also need different schemas for list views (fewer fields)
              vs. detail views (more fields).
            </p>
					</div>
					<div class="concept-card">
						<h5>Password Hashing</h5>
						<p>
              Never store passwords in plain text. Use bcrypt (via the <span class="mono">passlib</span>
              library) to create a one-way hash. When a user logs in, hash the submitted password and
              compare it to the stored hash. Even if the database is compromised, the original passwords
              remain unrecoverable.
            </p>
					</div>
					<div class="concept-card">
						<h5>JWT Structure</h5>
						<p>
              A JWT has three parts: header (algorithm), payload (claims like user ID, role, expiration),
              and signature (proves the token was issued by your server). The payload is Base64-encoded
              but <strong>not encrypted</strong> ‚Äî anyone can read it. Never put sensitive data in the
              payload. The signature prevents tampering ‚Äî if anyone modifies the payload, the signature
              validation fails.
            </p>
					</div>
					<div class="concept-card">
						<h5>OAuth2PasswordBearer</h5>
						<p>
              This is a FastAPI class that tells the framework where to find the token (in the
              Authorization header as a Bearer token). It also integrates with Swagger UI, adding a
              "lock" icon that lets you enter a token for testing protected endpoints. You pass it
              a <span class="mono">tokenUrl</span> pointing to your login endpoint.
            </p>
					</div>
				</div>
				<h4>Testing This Phase</h4>
				<ul>
					<li>Register a new user and verify the response contains no password field</li>
					<li>Register with the same email and verify a 409 Conflict response</li>
					<li>Login with correct credentials and verify tokens are returned</li>
					<li>Login with wrong password and verify a 401 response with a generic message</li>
					<li>Call <span class="mono">/auth/me</span> with a valid token and verify user data is returned</li>
					<li>Call <span class="mono">/auth/me</span> without a token and verify a 401 response</li>
					<li>Use the refresh token to get a new access token</li>
				</ul>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Returning the hashed password in responses.</strong> Always exclude it in your response schema. Use <span class="mono">model_config</span> with <span class="mono">from_attributes = True</span> in Pydantic v2 to enable ORM mode.</li>
						<li>
							<strong>Not differentiating access and refresh tokens.</strong> Include a <span class="mono">type</span> claim in the JWT payload. Validate that the <span class="mono">/auth/me</span> endpoint rejects refresh tokens and the <span class="mono">/auth/refresh</span> endpoint rejects access tokens.</li>
						<li>
							<strong>Revealing whether the email or password was wrong.</strong> Always return a generic "Invalid credentials" message. Specific messages help attackers enumerate valid emails.</li>
						<li>
							<strong>Putting business logic in the router.</strong> The router should not contain password hashing, email uniqueness checks, or token generation. All of that belongs in the service layer.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Users table exists in PostgreSQL with correct columns</li>
						<li>Register ‚Üí Login ‚Üí Call /me works end-to-end</li>
						<li>Token refresh works correctly</li>
						<li>Error cases return appropriate status codes and messages</li>
						<li>The project follows the Router ‚Üí Service ‚Üí Repository ‚Üí Model pattern</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 3 ‚Äî ROLE-BASED ACCESS CONTROL                        -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-3">
				<div class="phase-header">
					<div class="phase-number">Phase 3</div>
					<h3 class="phase-title">Role-Based Access Control &amp; Protected Routes</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Master FastAPI's dependency injection for access control</li>
						<li>Build reusable role-checking dependencies</li>
						<li>Understand dependency composition ‚Äî dependencies that depend on other dependencies</li>
						<li>Learn how to create dependency factories (functions that return dependencies)</li>
						<li>Add the profile update endpoint</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          A set of reusable dependency functions that enforce role-based access on any endpoint.
          After this phase, you can protect any route by simply adding a dependency like
          <span class="mono">Depends(require_role("admin"))</span> to the route function signature.
          You will also add the profile update endpoint.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/dependencies/roles.py</span>
								</td>
								<td>Role-checking dependency functions: <span class="mono">require_role</span>, <span class="mono">require_vendor</span>, <span class="mono">require_admin</span>.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Create the <span class="mono">require_role</span> factory function.</strong> This is
            a function that takes a role name (or list of role names) as an argument and returns a
            <strong>new dependency function</strong>. The inner function depends on
            <span class="mono">get_current_user</span>, checks the user's role, and either returns the
            user or raises <span class="mono">ForbiddenException</span>. This is a powerful pattern:
            a function that creates customized dependencies.
          </li>
					<li>
						<strong>Create convenience shortcuts.</strong> Define <span class="mono">require_vendor</span>
            as <span class="mono">require_role("vendor")</span> and <span class="mono">require_admin</span>
            as <span class="mono">require_role("admin")</span>. You can also create a
            <span class="mono">require_vendor_or_admin</span> that accepts either role.
          </li>
					<li>
						<strong>Add the profile update endpoint.</strong> In the auth router, add a PUT endpoint for
            <span class="mono">/api/v1/auth/me</span> that accepts updatable fields (full_name, phone)
            and updates the current user's record. This demonstrates combining authentication dependency
            with write operations.
          </li>
					<li>
						<strong>Test role enforcement.</strong> Register users with different roles. Verify that
            attempting to access an admin-only endpoint with a customer token returns 403, while an
            admin token succeeds. You will create actual admin and vendor endpoints in later phases,
            but you can create a temporary test route now for verification.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Dependency Factories</h5>
						<p>
              A dependency factory is a function that returns another function. When you write
              <span class="mono">require_role("admin")</span>, the outer function runs immediately and
              returns the inner checker function. FastAPI then uses that inner function as the dependency.
              This pattern lets you create parameterized dependencies ‚Äî a single factory produces
              different guards for different roles.
            </p>
					</div>
					<div class="concept-card">
						<h5>Dependency Composition</h5>
						<p>
              Your <span class="mono">require_role</span> dependency calls
              <span class="mono">get_current_user</span>, which calls <span class="mono">get_db</span>.
              FastAPI resolves this chain automatically. You declare the outermost dependency on your
              route, and the entire chain is invoked in the correct order. If any dependency fails
              (raises an exception), the route handler is never called.
            </p>
					</div>
				</div>
				<h4>Testing This Phase</h4>
				<ul>
					<li>A customer token cannot access vendor-only endpoints (403)</li>
					<li>A vendor token can access vendor-required endpoints (200)</li>
					<li>An admin token can access admin-required endpoints (200)</li>
					<li>An unauthenticated request still returns 401, not 403</li>
					<li>Profile update works and changes are persisted</li>
				</ul>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Confusing 401 and 403.</strong> 401 means "not authenticated" (no token or invalid token). 403 means "authenticated but not authorized" (valid token, wrong role). Get this distinction right ‚Äî it matters for API consumers.</li>
						<li>
							<strong>Not making role checks reusable.</strong> If you copy-paste role checking code into every route handler, you are doing it wrong. Dependencies are designed to be reused.</li>
						<li>
							<strong>Forgetting that admins might also need vendor abilities.</strong> Design your role hierarchy so that admin can do everything a vendor can do. You can handle this in the role checker by accepting a list of allowed roles.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>You have reusable <span class="mono">require_role</span>, <span class="mono">require_vendor</span>, and <span class="mono">require_admin</span> dependencies</li>
						<li>Role enforcement works correctly for all three roles</li>
						<li>Profile update endpoint works</li>
						<li>The dependency chain (role ‚Üí user ‚Üí db) resolves automatically</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 4 ‚Äî STORE MANAGEMENT                                  -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-4">
				<div class="phase-header">
					<div class="phase-number">Phase 4</div>
					<h3 class="phase-title">Store CRUD ‚Äî Vendor Functionality</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Build a complete CRUD feature using the layered architecture</li>
						<li>Learn path parameters and UUID validation</li>
						<li>Implement ownership verification (vendor can only edit their own store)</li>
						<li>Practice the full flow: Model ‚Üí Migration ‚Üí Repository ‚Üí Service ‚Üí Schema ‚Üí Router</li>
						<li>Understand one-to-one relationship enforcement (one store per vendor)</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          The complete store management feature. Vendors can create exactly one store, view it, and
          update its details. Any user can view a store's public profile. Admins can activate or
          deactivate stores. This is your first full CRUD implementation and sets the pattern for
          all subsequent features.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/store.py</span>
								</td>
								<td>Store SQLAlchemy model with relationship to User.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/store.py</span>
								</td>
								<td>Pydantic schemas: StoreCreate, StoreUpdate, StoreResponse.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/repositories/store.py</span>
								</td>
								<td>StoreRepository with CRUD methods, plus <span class="mono">get_by_owner_id</span>.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/store.py</span>
								</td>
								<td>StoreService with business logic: create store, update store, check ownership.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/stores.py</span>
								</td>
								<td>Store endpoints as defined in Section 4.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Define the Store model.</strong> Include the <span class="mono">owner_id</span>
            foreign key with a unique constraint (one store per vendor). Define the SQLAlchemy
            <span class="mono">relationship</span> to the User model.
          </li>
					<li>
						<strong>Generate and apply the migration.</strong> Verify the stores table is created with
            the correct foreign key and unique constraint.
          </li>
					<li>
						<strong>Build the repository.</strong> Standard CRUD methods plus a
            <span class="mono">get_by_owner_id</span> method (to check if a vendor already has a store).
          </li>
					<li>
						<strong>Build the service.</strong> The <span class="mono">create_store</span> method
            checks that the user is a vendor and does not already have a store, then creates it.
            The <span class="mono">update_store</span> method verifies ownership before allowing changes.
          </li>
					<li>
						<strong>Define Pydantic schemas.</strong> Separate create, update, and response schemas.
            The response schema should include the owner's basic info (nested schema).
          </li>
					<li>
						<strong>Build the router.</strong> Five endpoints as specified in Section 4. Use the role
            dependencies from Phase 3. The create endpoint requires vendor role. The update endpoint
            requires vendor role and ownership verification. The status endpoint requires admin role.
          </li>
					<li>
						<strong>Wire up the dependency for store service.</strong> Create a dependency function
            that constructs a StoreService with its repository and database session. Inject it into
            the router endpoints.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Ownership Verification Pattern</h5>
						<p>
              When a vendor tries to update a store, you must verify they own it. This pattern repeats
              throughout the project: load the resource, compare the owner ID to the current user's ID,
              raise 403 if they do not match. Implement this in the service layer, not the router. Consider
              creating a reusable helper method for this check.
            </p>
					</div>
					<div class="concept-card">
						<h5>Service Layer Dependencies</h5>
						<p>
              Your router endpoints should receive a service instance via dependency injection.
              Create a function like <span class="mono">get_store_service</span> that depends on
              <span class="mono">get_db</span>, creates a repository with the session, and returns a
              service instance with the repository. This keeps the router completely decoupled from the
              database layer.
            </p>
					</div>
				</div>
				<h4>Testing This Phase</h4>
				<ul>
					<li>A vendor can create a store (201)</li>
					<li>A vendor cannot create a second store (409)</li>
					<li>A customer cannot create a store (403)</li>
					<li>The store owner can update their store</li>
					<li>A different vendor cannot update someone else's store (403)</li>
					<li>Anyone can view a store's public profile</li>
					<li>An admin can deactivate a store</li>
					<li>Stores list with pagination works</li>
				</ul>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Not enforcing one store per vendor at the database level.</strong> Add a unique constraint on <span class="mono">owner_id</span> in the model. Business logic checks in the service layer are important but the database constraint is your safety net.</li>
						<li>
							<strong>Exposing internal IDs unnecessarily.</strong> In list views, include only the fields an API consumer needs. Avoid returning the full owner user object ‚Äî return a simplified version.</li>
						<li>
							<strong>Putting ownership checks in the router.</strong> This logic belongs in the service layer. The router should call <span class="mono">service.update_store(store_id, data, current_user)</span> and let the service handle permission checks.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>All five store endpoints work correctly via Swagger UI</li>
						<li>Ownership and role checks are enforced</li>
						<li>The layered architecture pattern is fully established and comfortable</li>
						<li>You can describe the flow of a request from router through service to repository and back</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 5 ‚Äî CATEGORIES                                        -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-5">
				<div class="phase-header">
					<div class="phase-number">Phase 5</div>
					<h3 class="phase-title">Category CRUD ‚Äî Admin Functionality</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Reinforce the CRUD pattern with a simpler entity</li>
						<li>Learn to auto-generate derived fields (slug from name)</li>
						<li>Practice admin-only route protection</li>
						<li>Build endpoints that are public for reading but protected for writing</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          A simple category management system. Admins create and manage categories, while all users
          (including unauthenticated visitors) can list them. Categories have a name, an
          auto-generated URL-friendly slug, and an optional description.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/category.py</span>
								</td>
								<td>Category model with name, slug, description, is_active.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/category.py</span>
								</td>
								<td>CategoryCreate, CategoryUpdate, CategoryResponse schemas.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/repositories/category.py</span>
								</td>
								<td>CategoryRepository with CRUD methods.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/category.py</span>
								</td>
								<td>CategoryService with slug generation and uniqueness checks.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/categories.py</span>
								</td>
								<td>Category endpoints.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>Follow the same pattern as Phase 4: model ‚Üí migration ‚Üí repository ‚Üí service ‚Üí schema ‚Üí router.</li>
					<li>In the service layer, generate the slug from the name (convert to lowercase, replace spaces with hyphens, remove special characters).</li>
					<li>The list endpoint is public (no auth required). The create and update endpoints require admin role.</li>
					<li>If you implement the delete endpoint (optional), check for existing products in that category before allowing deletion.</li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Public vs. Protected Endpoints on the Same Router</h5>
						<p>
              Not every endpoint on a router needs the same protection level. The GET list endpoint
              has no authentication dependency, while POST/PUT/DELETE endpoints use
              <span class="mono">Depends(require_admin)</span>. This is a common pattern ‚Äî read
              operations are often public while write operations are protected.
            </p>
					</div>
					<div class="concept-card">
						<h5>Derived Fields</h5>
						<p>
              The slug is not provided by the API consumer ‚Äî it is generated from the name in the
              service layer. This is a common pattern: the input schema contains fewer fields than the
              model, and the service layer fills in the derived values before passing data to the
              repository.
            </p>
					</div>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Admin can create categories and slugs are auto-generated</li>
						<li>Anyone can list categories without authentication</li>
						<li>Non-admin users cannot create, update, or delete categories</li>
						<li>Category names are unique</li>
						<li>This phase felt faster than Phase 4 ‚Äî the pattern is becoming second nature</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 6 ‚Äî PRODUCTS                                          -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-6">
				<div class="phase-header">
					<div class="phase-number">Phase 6</div>
					<h3 class="phase-title">Product CRUD with Pagination, Filtering &amp; Search</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Handle multiple query parameters with validation constraints</li>
						<li>Build dynamic SQLAlchemy queries (conditionally adding filters)</li>
						<li>Implement pagination with total count and page calculation</li>
						<li>Implement text search using database ILIKE or similar</li>
						<li>Load relationships eagerly to avoid N+1 query problems</li>
						<li>Use nested Pydantic models for rich response structures</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          Product management is the most feature-rich CRUD in the project. Vendors create products
          in their store, specifying name, description, price, stock, and category. The list endpoint
          supports pagination, filtering by category/store/price range, text search, and sorting.
          The detail endpoint returns a rich response with nested store and category information.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/product.py</span>
								</td>
								<td>Product model with foreign keys to stores and categories.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/product.py</span>
								</td>
								<td>ProductCreate, ProductUpdate, ProductResponse, ProductListResponse, PaginatedResponse schemas.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/repositories/product.py</span>
								</td>
								<td>ProductRepository with dynamic filtering, search, pagination, and eager relationship loading.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/product.py</span>
								</td>
								<td>ProductService with cross-entity validation and ownership checks.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/products.py</span>
								</td>
								<td>Product endpoints.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/pagination.py</span>
								</td>
								<td>Reusable paginated response wrapper schema.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Define the Product model.</strong> Include foreign keys to both stores and categories.
            Define relationships with back-population. Use <span class="mono">Numeric(10, 2)</span> for
            price and add check constraints for price &gt; 0 and stock &gt;= 0.
          </li>
					<li>
						<strong>Build the dynamic query in the repository.</strong> The list method starts with a
            base query, then conditionally appends <span class="mono">.where()</span> clauses based on
            which filter parameters are provided. If <span class="mono">category_id</span> is not None,
            add a category filter. If <span class="mono">search</span> is provided, add an ILIKE clause
            on name and description. Finally, apply sorting and pagination (limit/offset).
          </li>
					<li>
						<strong>Create the paginated response schema.</strong> A reusable generic wrapper that includes
            <span class="mono">items</span>, <span class="mono">total</span>, <span class="mono">page</span>,
            <span class="mono">size</span>, and <span class="mono">pages</span>. Calculate pages as
            ceiling of total divided by size.
          </li>
					<li>
						<strong>Build the product detail response.</strong> Include nested store info (store name, id)
            and category info (category name, slug) using nested Pydantic schemas. Later, you will add
            images and average rating.
          </li>
					<li>
						<strong>Handle ownership for create/update/delete.</strong> When a vendor creates a product,
            look up their store from the database and automatically set the <span class="mono">store_id</span>.
            The vendor does not specify their store ID in the request ‚Äî the system derives it. For update
            and delete, verify the product belongs to the vendor's store.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Dynamic Query Building</h5>
						<p>
              Building queries conditionally is a fundamental backend skill. Start with a base query,
              then check each optional parameter: if it has a value, append a filter. This approach
              scales cleanly ‚Äî adding a new filter means adding one more conditional block, without
              restructuring existing code. Never build SQL as raw strings with concatenation.
            </p>
					</div>
					<div class="concept-card">
						<h5>N+1 Query Problem</h5>
						<p>
              If you load 20 products and then access <span class="mono">product.store</span> on each
              one, SQLAlchemy will execute 20 additional queries (one per product to load its store).
              This is the N+1 problem. Solve it by using <span class="mono">selectinload</span> or
              <span class="mono">joinedload</span> in your query to eagerly load relationships in a
              single query. This is one of the most important performance patterns in ORM-based
              applications.
            </p>
					</div>
					<div class="concept-card">
						<h5>Query Parameter Validation</h5>
						<p>
              FastAPI's <span class="mono">Query()</span> function lets you add constraints to query
              parameters: minimum/maximum values (<span class="mono">ge</span>, <span class="mono">le</span>),
              maximum length, regex patterns, and descriptions. For example,
              <span class="mono">size: int = Query(default=20, ge=1, le=100)</span> ensures page size
              is always between 1 and 100. These constraints are automatically enforced and documented
              in Swagger.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Forgetting to count total results for pagination.</strong> You need two queries: one for the paginated results and one for the total count (without limit/offset). You can optimize this later, but correctness first.</li>
						<li>
							<strong>Not filtering out inactive products.</strong> Always add <span class="mono">is_active=True</span> to the base query for public endpoints. Vendors should see their own inactive products in their dashboard.</li>
						<li>
							<strong>Using Float for prices.</strong> Always use Numeric/Decimal. Floating-point arithmetic errors in financial calculations are a common source of bugs.</li>
						<li>
							<strong>Allowing vendors to create products in other vendors' stores.</strong> The store_id should be derived from the authenticated user, never accepted from the request body.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Products can be created, read, updated, and soft-deleted by the store owner</li>
						<li>Product listing supports pagination, category filter, store filter, price range, and search</li>
						<li>Product detail includes nested store and category information</li>
						<li>Inactive products are excluded from public listings</li>
						<li>Pagination response includes total count and calculated page numbers</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 7 ‚Äî FILE UPLOADS                                      -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-7">
				<div class="phase-header">
					<div class="phase-number">Phase 7</div>
					<h3 class="phase-title">File Upload for Product Images</h3>
					<span class="badge badge-important">Important</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Use FastAPI's <span class="mono">UploadFile</span> and <span class="mono">File()</span> for file uploads</li>
						<li>Combine file uploads with form data using <span class="mono">Form()</span>
						</li>
						<li>Validate file types and sizes</li>
						<li>Save files to disk and serve them as static files</li>
						<li>Handle file cleanup when deleting records</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          An endpoint to upload images for products and an endpoint to delete them. Images are saved
          to a local directory on the server. The file path is stored in the
          <span class="mono">product_images</span> table. One image can be marked as the primary
          display image for a product.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/product_image.py</span>
								</td>
								<td>ProductImage model.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/product_image.py</span>
								</td>
								<td>ProductImageResponse schema.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/product_image.py</span>
								</td>
								<td>Image upload service with file validation, saving, and cleanup.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/product_images.py</span>
								</td>
								<td>Upload and delete endpoints.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/utils/file_utils.py</span>
								</td>
								<td>Helper functions for file saving, validation, and deletion.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Define the ProductImage model.</strong> Include foreign key to products,
            image_url (relative path), is_primary flag, and sort_order.
          </li>
					<li>
						<strong>Create file utility functions.</strong> A function to validate the file (check content
            type against allowed types like image/jpeg, image/png, image/webp; check file size against
            the configured maximum). A function to save the file to disk with a unique filename
            (use UUID to prevent name collisions). A function to delete a file from disk.
          </li>
					<li>
						<strong>Build the upload endpoint.</strong> Accept both the file (<span class="mono">UploadFile</span>)
            and a boolean form field (<span class="mono">is_primary</span>) via <span class="mono">Form()</span>.
            You cannot mix <span class="mono">UploadFile</span> with a JSON body ‚Äî you must use form data
            for all fields. Validate the file, save it, create the database record, and return the image
            metadata.
          </li>
					<li>
						<strong>Configure static file serving.</strong> Mount a static files directory on your FastAPI
            app so that uploaded images can be accessed via URL.
          </li>
					<li>
						<strong>Build the delete endpoint.</strong> Verify ownership (the vendor owns the product
            the image belongs to), delete the file from disk, then delete the database record.
          </li>
					<li>
						<strong>Update the product detail response.</strong> Include the list of images as a
            nested array in the product response schema.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>UploadFile vs. bytes</h5>
						<p>
              FastAPI offers two ways to receive files: <span class="mono">bytes</span> (reads the
              entire file into memory) and <span class="mono">UploadFile</span> (provides a file-like
              object with a <span class="mono">read()</span> method). Always use
              <span class="mono">UploadFile</span> for production code ‚Äî it uses a temporary file on
              disk for large uploads, preventing memory exhaustion. It also provides the original
              filename and content type.
            </p>
					</div>
					<div class="concept-card">
						<h5>Mixing Files and Form Data</h5>
						<p>
              When an endpoint accepts a file upload, all non-file parameters must be sent as form
              fields, not JSON. This is an HTTP protocol limitation (multipart/form-data encoding).
              Use <span class="mono">Form()</span> for additional parameters alongside
              <span class="mono">File()</span> / <span class="mono">UploadFile</span>.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Not validating file content type.</strong> Never trust the file extension. Check the <span class="mono">content_type</span> attribute of the uploaded file. Better yet, read the first few bytes to verify the magic number matches an image format.</li>
						<li>
							<strong>Using the original filename.</strong> Always rename the file with a UUID to prevent path traversal attacks and naming collisions.</li>
						<li>
							<strong>Deleting the file before the database record.</strong> If the database delete fails, you have lost the file. Delete the database record first (within a transaction), then delete the file.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Images can be uploaded for products via multipart form data</li>
						<li>Invalid file types and oversized files are rejected with clear error messages</li>
						<li>Uploaded images are accessible via a URL</li>
						<li>Product detail endpoint includes the images list</li>
						<li>Deleting an image removes both the database record and the file</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 8 ‚Äî SHOPPING CART                                     -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-8">
				<div class="phase-header">
					<div class="phase-number">Phase 8</div>
					<h3 class="phase-title">Shopping Cart Functionality</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Handle upsert logic (add to cart or update quantity if already exists)</li>
						<li>Build computed response fields (line subtotals, cart total)</li>
						<li>Work with composite unique constraints</li>
						<li>Practice joining multiple tables for a rich response</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          A server-side shopping cart. Each authenticated user has a cart represented by
          <span class="mono">cart_items</span> rows in the database. Users can add products, change
          quantities, remove individual items, or clear the entire cart. The cart view endpoint
          returns all items with product details and a computed total.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/cart_item.py</span>
								</td>
								<td>CartItem model with composite unique constraint on (user_id, product_id).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/cart.py</span>
								</td>
								<td>CartItemCreate, CartItemUpdate, CartItemResponse (with product details), CartResponse (with total).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/repositories/cart.py</span>
								</td>
								<td>CartRepository with add/update/remove/clear/get_all methods.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/cart.py</span>
								</td>
								<td>CartService with stock validation and upsert logic.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/cart.py</span>
								</td>
								<td>Cart endpoints.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Define the CartItem model.</strong> Add a unique constraint on the combination of
            <span class="mono">user_id</span> and <span class="mono">product_id</span>. This prevents
            the same product appearing twice in a user's cart.
          </li>
					<li>
						<strong>Build the add-to-cart service logic.</strong> When adding a product: first check if
            a cart item already exists for this user + product. If yes, increment the quantity. If no,
            create a new cart item. In both cases, validate that the total quantity does not exceed the
            available stock.
          </li>
					<li>
						<strong>Build the cart view.</strong> Query all cart items for the current user, joining with
            the products table to get product name, price, and image. Calculate line subtotals
            (quantity √ó price) and the cart total (sum of all subtotals). Return these as computed fields
            in the Pydantic response.
          </li>
					<li>
						<strong>Handle edge cases.</strong> What if a product becomes inactive or out of stock after
            being added to the cart? You can either filter it out during the view or flag it for the user.
            A simple approach: include inactive items in the cart view but add a flag indicating they
            are unavailable.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Upsert Pattern</h5>
						<p>
              An "upsert" (update or insert) is a common database pattern. When adding to the cart,
              you try to find an existing record. If found, update it. If not, create one. In SQLAlchemy,
              you do this in the repository with a query-then-decide approach. Some databases support
              native upsert operations (ON CONFLICT), but the query-then-decide approach is simpler to
              understand and sufficient for this project's scale.
            </p>
					</div>
					<div class="concept-card">
						<h5>Computed Fields in Pydantic</h5>
						<p>
              The cart response includes fields that do not exist in the database: line subtotal and
              cart total. You calculate these in the service layer or use Pydantic's
              <span class="mono">@computed_field</span> (v2) or <span class="mono">@validator</span>
              (v1). The point is that your response schema can be richer than your database model.
            </p>
					</div>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Adding the same product twice increments quantity instead of creating a duplicate</li>
						<li>Quantity cannot exceed available stock</li>
						<li>Cart view shows product details, subtotals, and a total</li>
						<li>Items can be individually removed or the cart can be cleared entirely</li>
						<li>Each user sees only their own cart</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 9 ‚Äî ORDERS                                            -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-9">
				<div class="phase-header">
					<div class="phase-number">Phase 9</div>
					<h3 class="phase-title">Order Placement &amp; Management</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Execute multi-table writes within a single database transaction</li>
						<li>Understand database transaction boundaries and rollback on failure</li>
						<li>Implement price snapshotting (recording price at order time)</li>
						<li>Build a state machine for order status transitions</li>
						<li>Generate human-readable order numbers</li>
						<li>Handle complex, multi-step business logic in the service layer</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          The order placement flow takes the contents of the user's cart, creates an order with
          order items, decrements product stock, and clears the cart ‚Äî all in a single atomic
          transaction. If any step fails (e.g., a product is out of stock), everything rolls back.
          After placing an order, users can view their order history and details. Vendors can view
          and update the status of items from their store.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/order.py</span>
								</td>
								<td>Order model with status field, total_amount, order_number.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/models/order_item.py</span>
								</td>
								<td>OrderItem model with price snapshot, quantity, subtotal, item-level status.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/order.py</span>
								</td>
								<td>OrderCreate, OrderResponse, OrderDetailResponse, OrderItemResponse, OrderStatusUpdate.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/repositories/order.py</span>
								</td>
								<td>OrderRepository and OrderItemRepository.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/order.py</span>
								</td>
								<td>OrderService with place_order transactional logic and status update validation.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/orders.py</span>
								</td>
								<td>Customer and vendor order endpoints.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Define the Order and OrderItem models.</strong> Order has a foreign key to users
            and to addresses. OrderItem has foreign keys to orders, products, and stores. Include the
            <span class="mono">unit_price</span> and <span class="mono">subtotal</span> fields on
            OrderItem for price snapshotting.
          </li>
					<li>
						<strong>Build the <span class="mono">place_order</span> service method.</strong> This is
            the most complex service method in the project. Step by step within a single transaction:
            <ol>
							<li>Fetch all cart items for the user (with product details)</li>
							<li>Validate the cart is not empty</li>
							<li>Validate the shipping address belongs to the user</li>
							<li>For each cart item, verify the product is active and has enough stock</li>
							<li>Generate a unique order number (e.g., "ORD-" + date + sequential number)</li>
							<li>Create the order record with calculated total amount</li>
							<li>Create order item records, capturing the current price as <span class="mono">unit_price</span>
							</li>
							<li>Decrement stock on each product</li>
							<li>Delete all cart items for the user</li>
							<li>Commit the transaction</li>
						</ol>
            If any step fails, the session should rollback, undoing all changes.
          </li>
					<li>
						<strong>Build the status transition validation.</strong> Define valid transitions as a dictionary
            or set of rules. For example, an order in "pending" can move to "confirmed" or "cancelled",
            but not directly to "delivered". The service method checks the current status, verifies the
            requested new status is a valid transition, and raises an error if not.
          </li>
					<li>
						<strong>Build the vendor order view.</strong> Vendors see only order items where the
            <span class="mono">store_id</span> matches their store. This is why we stored
            <span class="mono">store_id</span> on the order item ‚Äî it makes vendor-scoped queries
            efficient.
          </li>
					<li>
						<strong>Build the customer order history.</strong> Paginated list of the user's orders,
            filtered by their <span class="mono">user_id</span>. The detail view includes nested
            order items with product information.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Database Transactions</h5>
						<p>
              A transaction groups multiple database operations into an all-or-nothing unit. If the
              stock decrement succeeds but the order creation fails, you do not want the stock change
              to persist. With async SQLAlchemy, the session object <strong>is</strong> the transaction
              boundary. All operations on the session within a single <span class="mono">async with</span>
              block are part of the same transaction. Call <span class="mono">await session.commit()</span>
              to persist, or let the session rollback on exception.
            </p>
					</div>
					<div class="concept-card">
						<h5>Price Snapshotting</h5>
						<p>
              When an order is placed, the product's current price is copied to the
              <span class="mono">unit_price</span> field on the order item. This is intentional
              denormalization. If the vendor later changes the product price, existing orders are
              not affected. This is how every real e-commerce system works ‚Äî the order is a historical
              record of what the customer paid.
            </p>
					</div>
					<div class="concept-card">
						<h5>State Machines</h5>
						<p>
              Order status is a state machine with defined transitions. Enforcing these transitions
              in code (not just in documentation) prevents invalid state changes. A simple dictionary
              mapping current states to lists of allowed next states is sufficient. This pattern applies
              to any entity with a lifecycle: orders, payments, tickets, etc.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Not wrapping order placement in a transaction.</strong> If you commit the order but fail to decrement stock, the data is inconsistent. Everything must succeed or everything must rollback.</li>
						<li>
							<strong>Allowing negative stock.</strong> Always check stock <strong>before</strong> decrementing. If two users order the last item simultaneously, one should fail. At this scale, simple check-then-decrement is fine. Real systems use database-level locking or optimistic concurrency.</li>
						<li>
							<strong>Allowing arbitrary status changes.</strong> Without transition validation, a caller could move an order from "pending" directly to "delivered", bypassing the entire fulfillment process.</li>
						<li>
							<strong>Forgetting to clear the cart.</strong> After placing an order, the cart should be empty. If you forget this step, the user might accidentally place the same order twice.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Placing an order from a cart creates the order, order items, decrements stock, and clears the cart</li>
						<li>Order items record the price at the time of ordering</li>
						<li>Placing an order with insufficient stock fails and rolls back everything</li>
						<li>Customers can view their order history and individual order details</li>
						<li>Vendors can view and update order items for their store only</li>
						<li>Status transitions are validated (invalid transitions are rejected)</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 10 ‚Äî REVIEWS                                          -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-10">
				<div class="phase-header">
					<div class="phase-number">Phase 10</div>
					<h3 class="phase-title">Review &amp; Rating System</h3>
					<span class="badge badge-important">Important</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Implement complex cross-table validation (user must have purchased the product)</li>
						<li>Work with aggregate queries (AVG rating, COUNT reviews)</li>
						<li>Handle unique constraints across multiple columns (one review per user per product)</li>
						<li>Build nested route patterns (<span class="mono">/products/{id}/reviews</span>)</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          Customers can write one review per product, but only if they have a delivered order
          containing that product. Reviews include a 1-5 star rating and an optional text comment.
          Anyone can view reviews for a product. The product detail endpoint will also include the
          average rating and review count.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/review.py</span>
								</td>
								<td>Review model with unique constraint on (user_id, product_id).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/review.py</span>
								</td>
								<td>ReviewCreate, ReviewResponse, ReviewListResponse (with aggregate data).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/repositories/review.py</span>
								</td>
								<td>ReviewRepository with creation, listing, and aggregate methods.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/review.py</span>
								</td>
								<td>ReviewService with purchase verification and duplicate checking.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/reviews.py</span>
								</td>
								<td>Review endpoints nested under products.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Define the Review model.</strong> Include foreign keys to users and products.
            Add a composite unique constraint on <span class="mono">(user_id, product_id)</span>
            to ensure one review per customer per product at the database level. Use a check
            constraint to ensure rating is between 1 and 5.
          </li>
					<li>
						<strong>Build the purchase verification logic.</strong> In the service layer, before
            allowing a review, query the order_items table to check if there exists a delivered
            order item where the <span class="mono">product_id</span> matches the product being
            reviewed and the order's <span class="mono">user_id</span> matches the current user.
            This is a cross-table query that joins orders and order_items.
          </li>
					<li>
						<strong>Build the create review endpoint.</strong> This endpoint is nested under
            the product: <span class="mono">POST /api/v1/products/{product_id}/reviews</span>.
            The service checks: product exists, user has purchased it, user has not already
            reviewed it. If all checks pass, create the review.
          </li>
					<li>
						<strong>Build the list reviews endpoint.</strong> Return paginated reviews for a product.
            Include the reviewer's full name (but not their email) for display. Also return
            aggregate data: average rating (rounded to one decimal) and total review count.
          </li>
					<li>
						<strong>Update the product detail response.</strong> Add <span class="mono">average_rating</span>
            and <span class="mono">review_count</span> fields. You can calculate these either via a
            separate query or by including them as part of the product query using a subquery.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Cross-Table Validation</h5>
						<p>
              The review creation requires validating data across three tables: users, orders, and
              order_items. This is not a simple field validation ‚Äî it is a business rule that requires
              a database query. This type of validation always lives in the service layer, never in
              Pydantic schemas (which only validate the structure and types of input data, not business
              rules that require database access).
            </p>
					</div>
					<div class="concept-card">
						<h5>Aggregate Queries</h5>
						<p>
              SQL aggregate functions like <span class="mono">AVG()</span> and <span class="mono">COUNT()</span>
              compute values across multiple rows. In SQLAlchemy, you use <span class="mono">func.avg()</span>
              and <span class="mono">func.count()</span>. These are essential for any reporting or
              summary feature. Understanding how to combine aggregates with regular queries (subqueries
              or separate queries) is a fundamental database skill.
            </p>
					</div>
					<div class="concept-card">
						<h5>Nested Route Design</h5>
						<p>
              Reviews are a sub-resource of products, so they live under
              <span class="mono">/products/{product_id}/reviews</span>. This URL structure communicates
              the relationship between the resources. In FastAPI, you can either put these in the
              products router or create a separate reviews router and include it with the appropriate
              prefix. Either approach works ‚Äî consistency is what matters.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Allowing reviews without purchase verification.</strong> Without this check, anyone could review any product, undermining the review system's credibility.</li>
						<li>
							<strong>Exposing reviewer email addresses.</strong> Only show the reviewer's display name, never their email. This is a privacy concern.</li>
						<li>
							<strong>Not handling the unique constraint violation gracefully.</strong> If a user tries to review the same product twice, catch the database integrity error and return a clear 409 Conflict message rather than a 500 Internal Server Error.</li>
						<li>
							<strong>Calculating averages in Python instead of SQL.</strong> Loading all reviews into memory to calculate an average is wasteful. Use <span class="mono">func.avg()</span> in your database query ‚Äî let the database do the math.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Only users with a delivered order for the product can write a review</li>
						<li>One review per user per product is enforced</li>
						<li>Reviews list shows reviewer names, ratings, comments, and dates</li>
						<li>Average rating and review count are included in both the review listing and product detail</li>
						<li>Attempting to review without a purchase returns a clear error</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 11 ‚Äî ADDRESSES                                        -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-11">
				<div class="phase-header">
					<div class="phase-number">Phase 11</div>
					<h3 class="phase-title">Address Management</h3>
					<span class="badge badge-important">Important</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Manage one-to-many relationships with user-scoped data</li>
						<li>Implement "default" selection logic (only one default per user)</li>
						<li>Handle referential integrity constraints (addresses referenced by orders)</li>
						<li>Practice the <span class="mono">/me/</span> URL pattern for user-specific resources</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          Customers can create, view, update, and delete delivery addresses. Each user can have
          multiple addresses but only one can be marked as default. Addresses are required when
          placing an order. Addresses that are referenced by existing orders cannot be deleted.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/models/address.py</span>
								</td>
								<td>Address model with all fields from the schema section.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/schemas/address.py</span>
								</td>
								<td>AddressCreate, AddressUpdate, AddressResponse.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/repositories/address.py</span>
								</td>
								<td>AddressRepository with user-scoped queries.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/services/address.py</span>
								</td>
								<td>AddressService with default management logic.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/routers/addresses.py</span>
								</td>
								<td>Address endpoints under <span class="mono">/me/addresses</span>.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Define the Address model.</strong> Include all columns from the schema section.
            Foreign key to users. No unique constraints on address fields ‚Äî a user might have two
            addresses in the same city.
          </li>
					<li>
						<strong>Build the default address logic.</strong> When creating or updating an address
            with <span class="mono">is_default=True</span>, first set all other addresses for this
            user to <span class="mono">is_default=False</span>, then set the target address to true.
            If this is the user's first address, automatically mark it as default regardless of the
            input value.
          </li>
					<li>
						<strong>Build the delete logic.</strong> Before deleting, check if any orders reference
            this address as their shipping address. If so, reject the deletion with a clear error
            message. If the deleted address was the default, promote the most recently created
            remaining address to default.
          </li>
					<li>
						<strong>Scope all queries to the current user.</strong> Every repository method that
            returns addresses should filter by <span class="mono">user_id</span>. The service
            layer passes the current user's ID to ensure users can only see and manage their own
            addresses. If a user tries to access an address that belongs to someone else, return
            404 (not 403) to avoid revealing the address exists.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>User-Scoped Resources</h5>
						<p>
              Addresses are a user-owned resource. Every query must include a
              <span class="mono">user_id</span> filter. The URL pattern <span class="mono">/me/addresses</span>
              signals that these endpoints always operate on the authenticated user's data. You never
              need to pass a user ID in the URL ‚Äî it comes from the authentication dependency. This
              pattern repeats for any user-owned resource: carts, orders, wishlists.
            </p>
					</div>
					<div class="concept-card">
						<h5>Default Selection Pattern</h5>
						<p>
              Ensuring "only one default" in a one-to-many relationship is a common pattern. The
              approach is: before marking a record as default, unmark all other records for the same
              parent. This can be done with a single UPDATE statement: "set is_default=false where
              user_id=X and id != target_id". Then set the target record's is_default to true.
              Do both operations in the same transaction.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Not scoping queries to the current user.</strong> Without the user_id filter, a user could access or modify another user's addresses by guessing address IDs.</li>
						<li>
							<strong>Allowing deletion of order-referenced addresses.</strong> This would break order records. Always check for references before deleting.</li>
						<li>
							<strong>Multiple defaults.</strong> Race conditions could theoretically create two defaults, but at this project's scale, the simple unmark-then-mark approach is sufficient.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Users can create, list, update, and delete their own addresses</li>
						<li>Users cannot access other users' addresses</li>
						<li>Only one address per user can be default</li>
						<li>First address is automatically set as default</li>
						<li>Addresses referenced by orders cannot be deleted</li>
						<li>The order placement flow (Phase 9) uses the address</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 12 ‚Äî BACKGROUND TASKS                                 -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-12">
				<div class="phase-header">
					<div class="phase-number">Phase 12</div>
					<h3 class="phase-title">Background Tasks with Celery</h3>
					<span class="badge badge-important">Important</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Use FastAPI's built-in <span class="mono">BackgroundTasks</span> for simple fire-and-forget work</li>
						<li>Set up Celery with Redis as the message broker</li>
						<li>Create Celery tasks for work that should survive server restarts</li>
						<li>Understand the difference between in-process background tasks and external task queues</li>
						<li>Simulate email sending as a background task</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          Two types of background processing. First, use FastAPI's <span class="mono">BackgroundTasks</span>
          to log order placement events after the response is sent. Second, set up Celery with Redis
          to simulate sending email notifications (order confirmation, status updates). The emails
          are not actually sent ‚Äî they are logged to a file or console, simulating the work.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/worker.py</span>
								</td>
								<td>Celery application instance and configuration.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/tasks/email.py</span>
								</td>
								<td>Celery tasks: send_order_confirmation, send_status_update.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/tasks/__init__.py</span>
								</td>
								<td>Task package initialization.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Start with FastAPI BackgroundTasks.</strong> Modify the order placement endpoint
            to accept a <span class="mono">BackgroundTasks</span> parameter. After placing the order
            (but before returning the response), add a background task that logs the order details.
            The response is sent immediately; the logging happens afterward in the same process.
          </li>
					<li>
						<strong>Set up Celery.</strong> Create a Celery application instance in
            <span class="mono">worker.py</span>. Configure it to use Redis as both the broker
            (message queue) and the result backend. The Redis URL comes from your settings.
          </li>
					<li>
						<strong>Create email tasks.</strong> Define Celery tasks that simulate sending emails.
            The <span class="mono">send_order_confirmation</span> task accepts an order ID and
            user email, logs a message like "Sending order confirmation to user@example.com for
            order ORD-20240115-001", and waits a few seconds (simulating network latency). In a
            real application, this would call an email service API.
          </li>
					<li>
						<strong>Trigger Celery tasks from the API.</strong> In the order placement service,
            after successfully creating the order, call <span class="mono">send_order_confirmation.delay(order_id, user_email)</span>.
            The <span class="mono">.delay()</span> method sends the task to the Redis queue and returns
            immediately ‚Äî the API response is not delayed.
          </li>
					<li>
						<strong>Run the Celery worker.</strong> Start the Celery worker process separately
            (using the Celery CLI). Verify that tasks are picked up from the queue and executed.
            You will add this to Docker Compose in Phase 17.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>FastAPI BackgroundTasks vs. Celery</h5>
						<p>
							<span class="mono">BackgroundTasks</span> runs in the same process as the API server.
              It is perfect for quick, non-critical work (logging, updating a counter). But if the
              server restarts, pending tasks are lost. Celery runs in a separate process with a
              persistent message queue. Tasks survive server restarts, can be retried on failure,
              and can be distributed across multiple workers. Use BackgroundTasks for simplicity,
              Celery for reliability.
            </p>
					</div>
					<div class="concept-card">
						<h5>Message Broker Pattern</h5>
						<p>
              Celery does not call tasks directly. It puts a message on a queue (in Redis). A
              separate worker process reads messages from the queue and executes the tasks. This
              decoupling means the API and the worker can scale independently, and the API never
              blocks waiting for task completion. This is the fundamental pattern behind all
              distributed task systems.
            </p>
					</div>
					<div class="concept-card">
						<h5>Task Serialization</h5>
						<p>
              When you call <span class="mono">.delay(order_id, email)</span>, Celery serializes
              the arguments (typically as JSON) and puts them in Redis. The worker deserializes
              them and calls the function. This means task arguments must be serializable ‚Äî you
              cannot pass SQLAlchemy model instances or database sessions to Celery tasks. Pass
              IDs and simple values, and have the task query the database if it needs more data.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Passing complex objects to Celery tasks.</strong> Only pass simple, serializable values (strings, numbers, UUIDs as strings). The task function should fetch any complex data it needs from the database.</li>
						<li>
							<strong>Not starting the Celery worker.</strong> If you only start the FastAPI server, tasks are added to the queue but never executed. You need to run the Celery worker as a separate process.</li>
						<li>
							<strong>Using BackgroundTasks for critical work.</strong> If order confirmation emails must be sent reliably, use Celery. BackgroundTasks provides no retry mechanism and tasks are lost on crash.</li>
						<li>
							<strong>Importing the FastAPI app inside Celery tasks.</strong> This creates circular imports. Celery tasks should be self-contained ‚Äî they have their own database connection if needed, independent of the FastAPI application context.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Order placement triggers a FastAPI BackgroundTask that logs the event</li>
						<li>Celery worker starts and connects to Redis</li>
						<li>Order confirmation email task is sent to the queue and executed by the worker</li>
						<li>API response time is not affected by background task execution</li>
						<li>You understand when to use BackgroundTasks vs. Celery</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 13 ‚Äî REDIS CACHING                                    -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-13">
				<div class="phase-header">
					<div class="phase-number">Phase 13</div>
					<h3 class="phase-title">Redis Caching Basics</h3>
					<span class="badge badge-important">Important</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Connect to Redis from a FastAPI application using an async Redis client</li>
						<li>Implement the cache-aside (lazy loading) pattern</li>
						<li>Serialize and deserialize Python objects for Redis storage</li>
						<li>Set TTL (time-to-live) values for cached data</li>
						<li>Invalidate cache entries when underlying data changes</li>
						<li>Create a reusable caching utility or dependency</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          Add Redis caching to frequently-read, rarely-written data. Specifically: cache the
          category list (since categories change infrequently but are read on every product browse)
          and cache individual product detail pages. When categories or products are updated,
          invalidate the relevant cache entries.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/cache.py</span>
								</td>
								<td>Redis connection setup, cache utility functions (get, set, delete, get_or_set).</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Set up the Redis connection.</strong> Use an async Redis client library (like
            <span class="mono">redis-py</span> with its async support, or <span class="mono">aioredis</span>).
            Create a connection pool at application startup and close it at shutdown. Expose a
            dependency function <span class="mono">get_redis</span> similar to
            <span class="mono">get_db</span>.
          </li>
					<li>
						<strong>Create caching utility functions.</strong> Build helper functions for common
            cache operations:
            <ul>
							<li>
								<strong>cache_get(key)</strong> ‚Äî retrieve and deserialize a cached value</li>
							<li>
								<strong>cache_set(key, value, ttl)</strong> ‚Äî serialize and store a value with expiration</li>
							<li>
								<strong>cache_delete(key)</strong> ‚Äî remove a specific cache entry</li>
							<li>
								<strong>cache_delete_pattern(pattern)</strong> ‚Äî remove all keys matching a pattern (for bulk invalidation)</li>
						</ul>
            Use JSON serialization for the cached values.
          </li>
					<li>
						<strong>Cache the category list.</strong> In the category service's list method, before
            querying the database, check the cache for a key like <span class="mono">"categories:all"</span>.
            If found, return the cached data. If not, query the database, cache the result with a
            TTL of one hour, and return it.
          </li>
					<li>
						<strong>Invalidate category cache on changes.</strong> When a category is created,
            updated, or deleted, delete the <span class="mono">"categories:all"</span> cache key.
            The next request will trigger a fresh database query and re-cache the data.
          </li>
					<li>
						<strong>Cache product detail pages.</strong> Use keys like
            <span class="mono">"product:{product_id}"</span>. Set a TTL of fifteen minutes.
            Invalidate when the product is updated or deleted.
          </li>
					<li>
						<strong>Update the health check.</strong> Add Redis connectivity to the health check
            endpoint. Try a <span class="mono">PING</span> command and report the result.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Cache-Aside Pattern</h5>
						<p>
              Also called "lazy loading". The application is responsible for reading from and writing
              to the cache ‚Äî the cache does not know about the database. On read: check cache first,
              fall back to database, populate cache. On write: update database, invalidate cache.
              This is the simplest and most common caching pattern. It works well when reads vastly
              outnumber writes.
            </p>
					</div>
					<div class="concept-card">
						<h5>TTL (Time-to-Live)</h5>
						<p>
              Every cached value should have an expiration time. Without TTL, stale data lives in
              the cache forever (if you miss an invalidation). With TTL, even if you forget to
              invalidate, the data will eventually refresh. TTL is a safety net, not a replacement
              for proper invalidation. Choose TTL values based on how stale the data can be:
              categories can tolerate an hour; product prices might need fifteen minutes or less.
            </p>
					</div>
					<div class="concept-card">
						<h5>Serialization for Redis</h5>
						<p>
              Redis stores strings (or bytes). To cache a Python dictionary or a list of Pydantic
              objects, you must serialize them to JSON first and deserialize when reading. Be careful
              with types that JSON does not natively support ‚Äî UUIDs, datetimes, and Decimal values
              need custom serialization (convert to strings before JSON encoding).
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Caching user-specific data.</strong> Do not cache carts, orders, or profiles. The cache key space becomes huge and the hit rate is low. Cache shared, public data.</li>
						<li>
							<strong>Forgetting to invalidate.</strong> If you update a product but do not delete its cache entry, users see stale data until the TTL expires. Always pair write operations with cache invalidation.</li>
						<li>
							<strong>Caching errors.</strong> If the database query fails, do not cache the error response. Only cache successful results.</li>
						<li>
							<strong>Making the application fail if Redis is down.</strong> Wrap cache operations in try/except. If Redis is unavailable, fall back to the database. Caching should improve performance, not become a single point of failure.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Category list is served from cache on subsequent requests (verify by checking response times or Redis logs)</li>
						<li>Creating or updating a category invalidates the cache</li>
						<li>Product detail pages are cached and invalidated on update</li>
						<li>Health check reports Redis status</li>
						<li>The application works correctly even if Redis is temporarily unavailable (graceful fallback)</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 14 ‚Äî WEBSOCKETS                                       -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-14">
				<div class="phase-header">
					<div class="phase-number">Phase 14</div>
					<h3 class="phase-title">WebSocket for Order Status Updates</h3>
					<span class="badge badge-optional">Optional Extension</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Understand the difference between HTTP and WebSocket protocols</li>
						<li>Create a WebSocket endpoint in FastAPI</li>
						<li>Build a connection manager to track active WebSocket connections</li>
						<li>Send real-time updates to specific connected clients</li>
						<li>Handle WebSocket connection lifecycle (connect, disconnect, errors)</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          A WebSocket endpoint that allows customers to receive real-time notifications when their
          order status changes. When a vendor updates an order item's status (via the REST API),
          a message is pushed to any connected WebSocket clients who own that order.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/websockets/manager.py</span>
								</td>
								<td>ConnectionManager class that tracks active connections by user ID.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/websockets/orders.py</span>
								</td>
								<td>WebSocket endpoint for order updates.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Build the ConnectionManager.</strong> Create a class that maintains a dictionary
            mapping user IDs to their active WebSocket connections. It should have methods:
            <span class="mono">connect(user_id, websocket)</span>,
            <span class="mono">disconnect(user_id)</span>, and
            <span class="mono">send_to_user(user_id, message)</span>. Use a dictionary or a
            default dictionary with lists to support multiple connections per user.
          </li>
					<li>
						<strong>Create the WebSocket endpoint.</strong> Define a WebSocket route at
            <span class="mono">/api/v1/ws/orders</span>. When a client connects, authenticate
            them (extract the token from query parameters since WebSocket does not support
            Authorization headers in the same way). Register the connection with the manager.
            Keep the connection alive in a loop, listening for incoming messages (which you may
            not need for this one-way notification use case). Handle disconnection gracefully.
          </li>
					<li>
						<strong>Trigger notifications on status change.</strong> When the vendor updates an
            order item's status (in the order service), look up the order's customer user_id and
            send a WebSocket message via the connection manager. The message could be a JSON
            object with the order ID, new status, and a human-readable message.
          </li>
					<li>
						<strong>Test with a simple client.</strong> You can test WebSocket endpoints using
            browser developer tools, a simple HTML page with JavaScript's <span class="mono">WebSocket</span>
            API, or tools like Postman (which supports WebSockets).
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>HTTP vs. WebSocket</h5>
						<p>
              HTTP is request-response: the client asks, the server answers. WebSocket is full-duplex:
              once connected, either side can send messages at any time. WebSocket is ideal for real-time
              features where the server needs to push updates to the client without the client polling
              repeatedly. However, WebSocket connections are persistent and consume resources ‚Äî use them
              only when real-time push is genuinely needed.
            </p>
					</div>
					<div class="concept-card">
						<h5>WebSocket Authentication</h5>
						<p>
              WebSocket connections cannot use the standard <span class="mono">Authorization</span>
              header the way HTTP requests do. The common approach is to pass the JWT token as a
              query parameter during the connection handshake:
              <span class="mono">ws://localhost:8000/ws/orders?token=eyJ...</span>. Extract and
              validate the token in the WebSocket endpoint before accepting the connection.
            </p>
					</div>
					<div class="concept-card">
						<h5>Connection Management</h5>
						<p>
              The connection manager is an in-memory singleton. It only knows about connections to
              the current server process. In a production system with multiple server instances,
              you would need a shared pub/sub system (like Redis Pub/Sub) to broadcast messages
              across all instances. For this learning project, a single-process manager is sufficient.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Not handling disconnections.</strong> Clients can disconnect at any time (close browser tab, lose network). Always wrap WebSocket operations in try/except and clean up the connection from the manager on disconnect.</li>
						<li>
							<strong>Blocking the event loop.</strong> The WebSocket receive loop must be async. Never put blocking calls (like synchronous database queries) inside the WebSocket handler.</li>
						<li>
							<strong>Sending to a disconnected client.</strong> If the client disconnected but the manager has not been cleaned up yet, sending a message will raise an exception. Handle this gracefully.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>WebSocket endpoint accepts authenticated connections</li>
						<li>Connection manager tracks active connections by user ID</li>
						<li>When an order status changes, connected customers receive a real-time message</li>
						<li>Disconnection is handled gracefully without errors</li>
						<li>You understand the difference between HTTP polling and WebSocket push</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 15 ‚Äî MIDDLEWARE                                        -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-15">
				<div class="phase-header">
					<div class="phase-number">Phase 15</div>
					<h3 class="phase-title">Middleware ‚Äî Logging, CORS &amp; Error Handling</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Understand what middleware is and how it wraps every request/response</li>
						<li>Build custom middleware for request/response logging</li>
						<li>Add a request ID to every request for traceability</li>
						<li>Configure CORS (Cross-Origin Resource Sharing) middleware</li>
						<li>Build a global error handling middleware for unhandled exceptions</li>
						<li>Understand middleware execution order</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          Three pieces of middleware that wrap every request passing through your application.
          A <strong>request ID middleware</strong> that generates a unique ID for each request
          and includes it in the response headers. A <strong>logging middleware</strong> that
          logs the method, path, status code, and response time for every request. A
          <strong>CORS middleware</strong> using FastAPI's built-in support. You will also
          refine the global error handling to catch any unhandled exceptions and return a
          consistent 500 response.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">app/middleware/request_id.py</span>
								</td>
								<td>Middleware that generates and attaches a unique request ID.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/middleware/logging.py</span>
								</td>
								<td>Middleware that logs request/response details.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">app/middleware/__init__.py</span>
								</td>
								<td>Middleware package initialization.</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Build the request ID middleware.</strong> For every incoming request, generate a
            UUID. Store it on the request state (<span class="mono">request.state.request_id</span>)
            so it is accessible in route handlers and dependencies. Add it as a response header
            (<span class="mono">X-Request-ID</span>). This allows correlating client requests with
            server logs.
          </li>
					<li>
						<strong>Build the logging middleware.</strong> Record the start time before passing the
            request to the next handler. After the response comes back, calculate the elapsed time.
            Log the HTTP method, URL path, response status code, and duration. Include the request ID
            in the log message for traceability. Use Python's <span class="mono">logging</span>
            module with structured formatting.
          </li>
					<li>
						<strong>Configure CORS.</strong> Use FastAPI's built-in <span class="mono">CORSMiddleware</span>.
            Read allowed origins from your settings. For development, you might allow all origins;
            for production, restrict to specific domains. Also configure allowed methods, headers,
            and whether credentials are allowed.
          </li>
					<li>
						<strong>Add global error handling.</strong> Add a catch-all exception handler that catches
            any unhandled <span class="mono">Exception</span> (not your custom exceptions ‚Äî those
            already have handlers). Log the full traceback, then return a generic 500 response with
            a message like "Internal server error". Never expose the traceback or internal error
            details to the client.
          </li>
					<li>
						<strong>Register middleware in the correct order.</strong> Middleware executes in LIFO
            (last-in, first-out) order. The first middleware you add runs outermost. Add request ID
            first (outermost), then logging, then CORS. This ensures the request ID is available
            when the logging middleware runs.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Middleware Execution Flow</h5>
						<p>
              Middleware wraps your entire application. For each request, the flow is:
              Request ‚Üí Middleware A (before) ‚Üí Middleware B (before) ‚Üí Route Handler ‚Üí
              Middleware B (after) ‚Üí Middleware A (after) ‚Üí Response. Each middleware can modify
              the request before it reaches the handler, and modify the response before it reaches
              the client. It is like layers of an onion.
            </p>
					</div>
					<div class="concept-card">
						<h5>Request State</h5>
						<p>
              FastAPI's <span class="mono">request.state</span> is a mutable object where middleware
              and dependencies can attach data that persists for the lifetime of the request. Storing
              the request ID on <span class="mono">request.state</span> makes it accessible to any
              part of the application that has access to the request object.
            </p>
					</div>
					<div class="concept-card">
						<h5>CORS</h5>
						<p>
              CORS is a browser security mechanism that prevents web pages from making requests to a
              different domain than the one that served the page. Your API must include specific headers
              to allow cross-origin requests. This is only relevant when your API is called from a
              browser. Postman and server-to-server calls are not affected by CORS.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Logging sensitive data.</strong> Do not log request bodies for login endpoints (they contain passwords). Do not log Authorization headers (they contain tokens). Be selective about what you log.</li>
						<li>
							<strong>Exposing internal errors to clients.</strong> The global error handler must return a generic message. Log the full traceback server-side for debugging, but never send stack traces in the HTTP response.</li>
						<li>
							<strong>Getting middleware order wrong.</strong> If logging middleware runs before the request ID middleware, the log messages will not include the request ID. Think carefully about dependencies between middleware layers.</li>
						<li>
							<strong>Setting CORS to allow all origins in production.</strong> Use <span class="mono">allow_origins=["*"]</span> only during development. In production, specify the exact domains of your frontend applications.</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Every response includes an <span class="mono">X-Request-ID</span> header</li>
						<li>Server logs show method, path, status code, and duration for every request</li>
						<li>Log messages include the request ID for correlation</li>
						<li>CORS headers are present in responses</li>
						<li>An unhandled exception returns a clean 500 response (not a stack trace)</li>
						<li>Protected endpoint errors still return proper 401/403 responses</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 16 ‚Äî TESTING                                          -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-16">
				<div class="phase-header">
					<div class="phase-number">Phase 16</div>
					<h3 class="phase-title">Testing ‚Äî Unit &amp; Integration Tests</h3>
					<span class="badge badge-core">Core</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Set up pytest with async support for FastAPI testing</li>
						<li>Use FastAPI's <span class="mono">TestClient</span> (or <span class="mono">AsyncClient</span>) for integration tests</li>
						<li>Create test database fixtures and manage test data isolation</li>
						<li>Write unit tests for service layer business logic</li>
						<li>Write integration tests that hit API endpoints end-to-end</li>
						<li>Understand test fixtures, factories, and cleanup patterns</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          A comprehensive test suite covering the most important flows in the application.
          You will not test every single endpoint ‚Äî focus on the flows that have the most
          business logic and the highest risk of regression: authentication, order placement,
          role enforcement, and data validation.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">tests/conftest.py</span>
								</td>
								<td>Shared pytest fixtures: test database, test client, test users, auth helpers.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">tests/test_auth.py</span>
								</td>
								<td>Tests for registration, login, token refresh, and protected endpoints.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">tests/test_stores.py</span>
								</td>
								<td>Tests for store CRUD and ownership enforcement.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">tests/test_products.py</span>
								</td>
								<td>Tests for product CRUD, pagination, filtering, and search.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">tests/test_orders.py</span>
								</td>
								<td>Tests for order placement, stock decrements, and status transitions.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">tests/test_cart.py</span>
								</td>
								<td>Tests for cart operations.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">tests/factories.py</span>
								</td>
								<td>Helper functions to create test data (users, stores, products, etc.).</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Set up the test infrastructure.</strong> Install <span class="mono">pytest</span>,
            <span class="mono">pytest-asyncio</span>, and <span class="mono">httpx</span> (for async
            test client). Create a <span class="mono">conftest.py</span> that:
            <ul>
							<li>Creates a separate test database (or uses a transactional rollback strategy)</li>
							<li>Creates tables using SQLAlchemy's <span class="mono">create_all</span>
							</li>
							<li>Provides a database session fixture that rolls back after each test</li>
							<li>Overrides the <span class="mono">get_db</span> dependency in the FastAPI app to use the test session</li>
							<li>Provides a test client fixture</li>
						</ul>
					</li>
					<li>
						<strong>Create test data factories.</strong> Write helper functions that create test
            entities: <span class="mono">create_test_user(role="customer")</span>,
            <span class="mono">create_test_store(owner_id)</span>,
            <span class="mono">create_test_product(store_id, category_id)</span>. These factories
            provide default values for all fields, with the ability to override specific ones.
            This makes tests concise and readable.
          </li>
					<li>
						<strong>Create an auth helper.</strong> A fixture or function that creates a user, logs
            them in, and returns the access token as a header dictionary. This avoids repeating
            the registration-login flow in every test.
          </li>
					<li>
						<strong>Write authentication tests.</strong> Test the happy path (register, login, access
            protected endpoint). Test error cases (duplicate email, wrong password, expired token,
            missing token). Test role enforcement (customer cannot access admin endpoints).
          </li>
					<li>
						<strong>Write order placement tests.</strong> This is the most critical test. Set up a
            user with an address, a store with products, and items in the cart. Place the order and
            verify: order is created with correct total, order items have snapshotted prices, product
            stock is decremented, cart is empty. Also test failure cases: empty cart, insufficient
            stock, invalid address.
          </li>
					<li>
						<strong>Write CRUD tests for key entities.</strong> For stores and products, test create,
            read, update, and delete. Focus on ownership enforcement (vendor A cannot edit vendor B's
            products) and validation (invalid price, missing required fields).
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Test Isolation</h5>
						<p>
              Each test should be independent ‚Äî it should not depend on data created by other tests,
              and it should not leave data that affects other tests. The most common approach is to
              use a database transaction per test that is rolled back at the end. This way, every
              test starts with a clean database state. In pytest, you achieve this with a session-scoped
              fixture for table creation and a function-scoped fixture for the transactional session.
            </p>
					</div>
					<div class="concept-card">
						<h5>Dependency Override</h5>
						<p>
              FastAPI's <span class="mono">app.dependency_overrides</span> dictionary lets you
              replace any dependency with a test-specific version. The most important override is
              <span class="mono">get_db</span> ‚Äî you replace it with a function that returns your
              test database session. This is FastAPI's killer testing feature: you can swap out any
              infrastructure dependency (database, cache, external services) without changing
              application code.
            </p>
					</div>
					<div class="concept-card">
						<h5>Integration vs. Unit Tests</h5>
						<p>
							<strong>Integration tests</strong> hit the API endpoints via the test client and exercise
              the full stack (router ‚Üí service ‚Üí repository ‚Üí database). They are high-confidence
              but slower. <strong>Unit tests</strong> test individual functions (like service methods)
              in isolation, potentially mocking the repository. For this project, focus on integration
              tests ‚Äî they provide the best learning value and the most confidence that your
              application actually works.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Tests depending on each other.</strong> If test B only passes when test A runs first, your tests are not isolated. Use fixtures to set up all required data within each test.</li>
						<li>
							<strong>Not testing error cases.</strong> Happy-path tests are necessary but insufficient. The most valuable tests verify that your API rejects invalid input, unauthorized access, and impossible operations correctly.</li>
						<li>
							<strong>Testing implementation details.</strong> Test behavior (inputs and outputs), not how the code is structured internally. If you refactor the service layer, your tests should still pass without changes.</li>
						<li>
							<strong>Using the production database for tests.</strong> Always use a separate test database. Accidentally running tests against production data could be catastrophic.</li>
					</ul>
				</div>
				<h4>What to Test (Priority List)</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>Test Area</th>
								<th>Priority</th>
								<th>Key Test Cases</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Authentication</td>
								<td>
									<span class="badge badge-core">Core</span>
								</td>
								<td>Register, login, invalid credentials, token refresh, expired token</td>
							</tr>
							<tr>
								<td>Role Enforcement</td>
								<td>
									<span class="badge badge-core">Core</span>
								</td>
								<td>Customer blocked from admin routes, vendor blocked from admin routes</td>
							</tr>
							<tr>
								<td>Order Placement</td>
								<td>
									<span class="badge badge-core">Core</span>
								</td>
								<td>Successful order, empty cart, insufficient stock, stock decrement, cart cleared</td>
							</tr>
							<tr>
								<td>Product CRUD</td>
								<td>
									<span class="badge badge-important">Important</span>
								</td>
								<td>Create, pagination, filters, ownership, soft delete</td>
							</tr>
							<tr>
								<td>Cart Operations</td>
								<td>
									<span class="badge badge-important">Important</span>
								</td>
								<td>Add, update quantity, remove, stock validation</td>
							</tr>
							<tr>
								<td>Store Ownership</td>
								<td>
									<span class="badge badge-important">Important</span>
								</td>
								<td>Create store, one-per-vendor, ownership enforcement</td>
							</tr>
							<tr>
								<td>Reviews</td>
								<td>
									<span class="badge badge-optional">Optional Extension</span>
								</td>
								<td>Purchase verification, one-per-product, rating validation</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>Test suite runs with <span class="mono">pytest</span> and all tests pass</li>
						<li>Tests use a separate test database, not your development database</li>
						<li>Each test is independent and can run in any order</li>
						<li>Authentication, role enforcement, and order placement are thoroughly tested</li>
						<li>Both happy paths and error cases are covered</li>
						<li>You can run the full suite in under a minute</li>
					</ul>
				</div>
			</div>
			<!-- =========================================================== -->
			<!-- PHASE 17 ‚Äî DOCKER & DEPLOYMENT                              -->
			<!-- =========================================================== -->
			<div class="phase-card" id="phase-17">
				<div class="phase-header">
					<div class="phase-number">Phase 17</div>
					<h3 class="phase-title">Docker &amp; Deployment Basics</h3>
					<span class="badge badge-important">Important</span>
				</div>
				<div class="callout callout-learn">
					<div class="callout-header">üéØ Learning Objectives</div>
					<ul>
						<li>Write a multi-stage Dockerfile for a FastAPI application</li>
						<li>Create a Docker Compose configuration for local multi-service development</li>
						<li>Manage environment variables in Docker</li>
						<li>Understand container networking and service communication</li>
						<li>Configure health checks for containerized services</li>
						<li>Learn basic production deployment considerations</li>
					</ul>
				</div>
				<h4>What to Build</h4>
				<p>
          A complete Docker setup that runs the entire application stack locally with a single
          command: the FastAPI API server, PostgreSQL database, Redis cache, and Celery worker.
          All services are defined in a <span class="mono">docker-compose.yml</span> file and
          communicate over a shared Docker network.
        </p>
				<h4>Files to Create</h4>
				<div class="table-wrap">
					<table>
						<thead>
							<tr>
								<th>File</th>
								<th>Purpose</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<span class="mono">Dockerfile</span>
								</td>
								<td>Multi-stage Dockerfile for the FastAPI application.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">docker-compose.yml</span>
								</td>
								<td>Compose file defining all services: api, db, redis, celery-worker.</td>
							</tr>
							<tr>
								<td>
									<span class="mono">.dockerignore</span>
								</td>
								<td>Files to exclude from the Docker build context (similar to .gitignore).</td>
							</tr>
							<tr>
								<td>
									<span class="mono">docker-compose.override.yml</span>
								</td>
								<td>Optional overrides for development (volume mounts for live reloading).</td>
							</tr>
						</tbody>
					</table>
				</div>
				<h4>Step-by-Step Approach</h4>
				<ol>
					<li>
						<strong>Create the Dockerfile.</strong> Use a multi-stage build:
            <ul>
							<li>
								<strong>Stage 1 (builder):</strong> Start from a Python base image. Copy
                <span class="mono">requirements.txt</span> and install dependencies into a virtual
                environment. Copy the application code.</li>
							<li>
								<strong>Stage 2 (production):</strong> Start from a slim Python image. Copy the
                virtual environment from the builder stage. Copy the application code. Set environment
                variables. Define the command to run Uvicorn.</li>
						</ul>
            The multi-stage approach keeps the final image small by excluding build tools.
          </li>
					<li>
						<strong>Create the Docker Compose file.</strong> Define four services:
            <ul>
							<li>
								<strong>db:</strong> PostgreSQL container with a named volume for data persistence.
                Set database name, user, and password via environment variables.</li>
							<li>
								<strong>redis:</strong> Redis container, standard configuration.</li>
							<li>
								<strong>api:</strong> Your FastAPI application. Depends on db and redis.
                Map port 8000. Pass environment variables for database URL (using the Docker
                service name as the hostname, e.g., <span class="mono">postgresql+asyncpg://user:pass@db:5432/marketplace</span>),
                Redis URL, and other settings.</li>
							<li>
								<strong>celery-worker:</strong> Same application image but with a different
                command (run the Celery worker instead of Uvicorn). Depends on db and redis.</li>
						</ul>
					</li>
					<li>
						<strong>Configure Docker networking.</strong> Docker Compose creates a default network
            for all services. Services communicate using their service names as hostnames. The
            API connects to PostgreSQL at <span class="mono">db:5432</span> and Redis at
            <span class="mono">redis:6379</span>. No special network configuration is needed.
          </li>
					<li>
						<strong>Add health checks.</strong> Define health checks for each service in Docker Compose:
            <ul>
							<li>PostgreSQL: use <span class="mono">pg_isready</span>
							</li>
							<li>Redis: use <span class="mono">redis-cli ping</span>
							</li>
							<li>API: use <span class="mono">curl</span> to hit the <span class="mono">/api/v1/health</span> endpoint</li>
						</ul>
            The <span class="mono">depends_on</span> directive with the <span class="mono">condition: service_healthy</span>
            option ensures services start in the correct order.
          </li>
					<li>
						<strong>Handle database migrations in Docker.</strong> Alembic migrations need to run
            before the API starts. You can handle this by adding a startup script that runs
            <span class="mono">alembic upgrade head</span> before starting Uvicorn, or by creating
            a separate one-time migration service in Docker Compose.
          </li>
					<li>
						<strong>Create the .dockerignore file.</strong> Exclude <span class="mono">.git</span>,
            <span class="mono">__pycache__</span>, <span class="mono">.env</span>,
            <span class="mono">venv</span>, <span class="mono">tests</span>,
            <span class="mono">.pytest_cache</span>, and any other files not needed in the
            production image.
          </li>
					<li>
						<strong>Test the full stack.</strong> Run <span class="mono">docker-compose up --build</span>
            and verify that all services start, the API responds to health checks, and you can
            perform the full workflow (register, login, create store, add product, place order)
            entirely within the Docker environment.
          </li>
				</ol>
				<h4>Key Concepts to Understand</h4>
				<div class="concept-grid">
					<div class="concept-card">
						<h5>Multi-Stage Builds</h5>
						<p>
              A multi-stage Dockerfile has multiple <span class="mono">FROM</span> statements. Each
              stage can copy artifacts from previous stages. The first stage installs build
              dependencies (compilers, development headers) and compiles your application's
              dependencies. The final stage uses a minimal base image and copies only the runtime
              artifacts. This reduces the production image size significantly ‚Äî often from 1 GB+
              to under 200 MB.
            </p>
					</div>
					<div class="concept-card">
						<h5>Container Service Discovery</h5>
						<p>
              Inside a Docker Compose network, each service can reach other services using the
              service name as a hostname. Your FastAPI app connects to
              <span class="mono">db:5432</span> (not <span class="mono">localhost:5432</span>).
              This is because each service runs in its own container with its own network namespace.
              <span class="mono">localhost</span> inside the API container refers to the API container
              itself, not the PostgreSQL container.
            </p>
					</div>
					<div class="concept-card">
						<h5>Data Persistence with Volumes</h5>
						<p>
              Containers are ephemeral ‚Äî when removed, all data inside them is lost. For the
              PostgreSQL database, you must use a named Docker volume to persist data across
              container restarts. Without a volume, every <span class="mono">docker-compose down</span>
              would destroy your database. Volumes are defined at the bottom of the Compose file
              and mounted into the container.
            </p>
					</div>
					<div class="concept-card">
						<h5>Environment Variable Management</h5>
						<p>
              In Docker, environment variables can be set in the Dockerfile (<span class="mono">ENV</span>),
              in the Compose file (<span class="mono">environment:</span>), or in an external
              <span class="mono">.env</span> file referenced by the Compose file (<span class="mono">env_file:</span>).
              For secrets (database passwords, JWT secret keys), use the <span class="mono">.env</span>
              file approach and keep the file out of version control. For non-sensitive settings,
              you can define them directly in the Compose file.
            </p>
					</div>
				</div>
				<h4>Common Mistakes</h4>
				<div class="callout callout-warn">
					<div class="callout-header">‚ö†Ô∏è Watch Out For</div>
					<ul>
						<li>
							<strong>Using <span class="mono">localhost</span> in database URLs.</strong> Inside Docker, services communicate via service names. Replace <span class="mono">localhost</span> with the service name (<span class="mono">db</span>, <span class="mono">redis</span>).</li>
						<li>
							<strong>Not waiting for database readiness.</strong> The API container might start before PostgreSQL is ready to accept connections. Use Docker health checks with <span class="mono">depends_on: condition: service_healthy</span> or add retry logic to your database connection.</li>
						<li>
							<strong>Forgetting to persist the database volume.</strong> Without a named volume, your data disappears when containers are recreated.</li>
						<li>
							<strong>Copying <span class="mono">.env</span> into the Docker image.</strong> Use the <span class="mono">.dockerignore</span> to exclude <span class="mono">.env</span> and pass environment variables through Docker Compose instead.</li>
						<li>
							<strong>Not running migrations before starting the API.</strong> The API will crash if the database tables do not exist. Ensure migrations run as part of the startup process.</li>
					</ul>
				</div>
				<h4>Basic Production Considerations</h4>
				<div class="callout callout-info">
					<div class="callout-header">üí° Beyond This Learning Project</div>
					<p>
            This project teaches you local Docker deployment. For actual production deployment,
            you would additionally need:
          </p>
					<ul>
						<li>
							<strong>Reverse proxy</strong> (Nginx or Traefik) in front of Uvicorn for SSL termination and static file serving</li>
						<li>
							<strong>Multiple Uvicorn workers</strong> (using Gunicorn as a process manager) for handling concurrent requests</li>
						<li>
							<strong>Managed database</strong> (like Amazon RDS or Google Cloud SQL) instead of a PostgreSQL container</li>
						<li>
							<strong>Managed Redis</strong> (like ElastiCache or Redis Cloud)</li>
						<li>
							<strong>CI/CD pipeline</strong> (GitHub Actions, GitLab CI) for automated testing and deployment</li>
						<li>
							<strong>Monitoring and logging</strong> (Sentry for errors, structured logging to a log aggregator)</li>
						<li>
							<strong>Container orchestration</strong> (Kubernetes, ECS, or a simpler platform like Fly.io or Railway)</li>
					</ul>
				</div>
				<h4>‚úÖ Checkpoint</h4>
				<div class="checkpoint">
					<ul>
						<li>
							<span class="mono">docker-compose up --build</span> starts all services without errors</li>
						<li>API is accessible at <span class="mono">http://localhost:8000</span>
						</li>
						<li>Health check shows all services (database, Redis) as connected</li>
						<li>Full workflow works: register ‚Üí login ‚Üí create store ‚Üí add product ‚Üí add to cart ‚Üí place order</li>
						<li>Database data persists across container restarts</li>
						<li>Celery worker processes background tasks</li>
						<li>Stopping and restarting containers does not lose data</li>
					</ul>
				</div>
			</div>
		</section>
		<!-- end section-5 -->
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 6 ‚Äî PROJECT STRUCTURE                                -->
		<!-- =========================================================== -->
		<section id="section-6" class="content-section">
			<div class="section-header">
				<span class="section-number">06</span>
				<h2 class="section-title">Project Structure</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>The complete folder and file structure for the marketplace project</li>
					<li>What each directory is responsible for and why it exists</li>
					<li>Naming conventions for files, classes, and functions</li>
					<li>How the structure supports the layered architecture pattern</li>
				</ul>
			</div>
			<h3 id="s6-tree">6.1 Complete Folder Structure</h3>
			<p>
        Below is the complete project directory tree. You do not need to create every file at once ‚Äî
        files are added incrementally as you progress through the phases. However, the directory
        structure should be established in Phase 1 so you have a clear place for everything.
      </p>
			<div class="file-tree">
				<pre>
marketplace-api/
‚îú‚îÄ‚îÄ alembic/
‚îÇ   ‚îú‚îÄ‚îÄ versions/              <span class="tree-comment"># Auto-generated migration files</span>
‚îÇ   ‚îú‚îÄ‚îÄ env.py                 <span class="tree-comment"># Alembic environment configuration</span>
‚îÇ   ‚îî‚îÄ‚îÄ script.py.mako         <span class="tree-comment"># Migration file template</span>
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py                <span class="tree-comment"># FastAPI application entry point</span>
‚îÇ   ‚îú‚îÄ‚îÄ config.py              <span class="tree-comment"># Pydantic BaseSettings configuration</span>
‚îÇ   ‚îú‚îÄ‚îÄ database.py            <span class="tree-comment"># Async engine, session factory, get_db</span>
‚îÇ   ‚îú‚îÄ‚îÄ cache.py               <span class="tree-comment"># Redis connection and cache utilities (Phase 13)</span>
‚îÇ   ‚îú‚îÄ‚îÄ worker.py              <span class="tree-comment"># Celery application instance (Phase 12)</span>
‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py          <span class="tree-comment"># Custom exception classes and handlers</span>
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py        <span class="tree-comment"># Import all models for Alembic discovery</span>
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py            <span class="tree-comment"># Declarative base with shared columns</span>
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ category.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_image.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order_item.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ review.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ address.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cart_item.py
‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py            <span class="tree-comment"># UserCreate, UserResponse, TokenResponse, etc.</span>
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ category.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_image.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ review.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ address.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cart.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pagination.py     <span class="tree-comment"># Reusable paginated response wrapper</span>
‚îÇ   ‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ category.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ review.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ address.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cart.py
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py            <span class="tree-comment"># JWT and password utilities</span>
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ category.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_image.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ review.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ address.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cart.py
‚îÇ   ‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ health.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stores.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ categories.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_images.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ reviews.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ addresses.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cart.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ admin.py
‚îÇ   ‚îú‚îÄ‚îÄ dependencies/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py            <span class="tree-comment"># get_current_user dependency</span>
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ roles.py           <span class="tree-comment"># require_role, require_vendor, require_admin</span>
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services.py       <span class="tree-comment"># Service factory dependencies (get_product_service, etc.)</span>
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ request_id.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging.py
‚îÇ   ‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ email.py           <span class="tree-comment"># Celery email tasks (Phase 12)</span>
‚îÇ   ‚îú‚îÄ‚îÄ websockets/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.py         <span class="tree-comment"># Connection manager (Phase 14)</span>
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ orders.py          <span class="tree-comment"># WebSocket endpoint (Phase 14)</span>
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ file_utils.py      <span class="tree-comment"># File upload helpers (Phase 7)</span>
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py            <span class="tree-comment"># Shared fixtures: test db, test client, auth helpers</span>
‚îÇ   ‚îú‚îÄ‚îÄ factories.py           <span class="tree-comment"># Test data factory functions</span>
‚îÇ   ‚îú‚îÄ‚îÄ test_auth.py
‚îÇ   ‚îú‚îÄ‚îÄ test_stores.py
‚îÇ   ‚îú‚îÄ‚îÄ test_products.py
‚îÇ   ‚îú‚îÄ‚îÄ test_cart.py
‚îÇ   ‚îú‚îÄ‚îÄ test_orders.py
‚îÇ   ‚îî‚îÄ‚îÄ test_reviews.py
‚îú‚îÄ‚îÄ uploads/                   <span class="tree-comment"># Uploaded product images (gitignored)</span>
‚îú‚îÄ‚îÄ alembic.ini                <span class="tree-comment"># Alembic configuration</span>
‚îú‚îÄ‚îÄ requirements.txt           <span class="tree-comment"># Python dependencies</span>
‚îú‚îÄ‚îÄ Dockerfile                 <span class="tree-comment"># Multi-stage Docker build (Phase 17)</span>
‚îú‚îÄ‚îÄ docker-compose.yml         <span class="tree-comment"># Multi-service development setup (Phase 17)</span>
‚îú‚îÄ‚îÄ .env                       <span class="tree-comment"># Environment variables (gitignored)</span>
‚îú‚îÄ‚îÄ .env.example               <span class="tree-comment"># Environment variable template (committed)</span>
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ .dockerignore
‚îî‚îÄ‚îÄ README.md
        </pre>
			</div>
			<h3 id="s6-directories">6.2 Directory Explanations</h3>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Directory</th>
							<th>Responsibility</th>
							<th>Key Rule</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<span class="mono">app/models/</span>
							</td>
							<td>SQLAlchemy ORM model classes, one file per database table</td>
							<td>Purely declarative ‚Äî no business logic, no queries</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/schemas/</span>
							</td>
							<td>Pydantic models for request validation and response serialization</td>
							<td>Separate schemas for create, update, and response. Never use one schema for everything.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/repositories/</span>
							</td>
							<td>Database access layer ‚Äî all SQLAlchemy queries live here</td>
							<td>No business logic. No HTTP awareness. Receives a database session, returns data.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/services/</span>
							</td>
							<td>Business logic layer ‚Äî validation, authorization, orchestration</td>
							<td>No HTTP concepts (no status codes, no request/response objects). No direct SQL.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/routers/</span>
							</td>
							<td>HTTP endpoint definitions ‚Äî thin orchestration layer</td>
							<td>Parse input, call service, return output. Minimal logic.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/dependencies/</span>
							</td>
							<td>FastAPI dependency functions used across routers</td>
							<td>Authentication, authorization, and service factory dependencies</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/middleware/</span>
							</td>
							<td>Request/response middleware functions</td>
							<td>Cross-cutting concerns that apply to every request</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/tasks/</span>
							</td>
							<td>Celery task definitions for background processing</td>
							<td>Self-contained ‚Äî do not import the FastAPI app or its dependencies</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/websockets/</span>
							</td>
							<td>WebSocket endpoints and connection management</td>
							<td>Separate from REST routers to keep concerns clean</td>
						</tr>
						<tr>
							<td>
								<span class="mono">app/utils/</span>
							</td>
							<td>Utility functions (file handling, slug generation, etc.)</td>
							<td>Stateless helper functions ‚Äî no dependencies on application state</td>
						</tr>
						<tr>
							<td>
								<span class="mono">tests/</span>
							</td>
							<td>All test files with shared fixtures and factories</td>
							<td>Mirror the app structure loosely. Each test file covers one domain.</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h3 id="s6-naming">6.3 Naming Conventions</h3>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Element</th>
							<th>Convention</th>
							<th>Example</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Python files</td>
							<td>Lowercase with underscores (snake_case)</td>
							<td>
								<span class="mono">product_image.py</span>, <span class="mono">cart_item.py</span>
							</td>
						</tr>
						<tr>
							<td>SQLAlchemy models</td>
							<td>PascalCase, singular noun</td>
							<td>
								<span class="mono">User</span>, <span class="mono">Product</span>, <span class="mono">OrderItem</span>
							</td>
						</tr>
						<tr>
							<td>Database table names</td>
							<td>Lowercase, plural, underscored</td>
							<td>
								<span class="mono">users</span>, <span class="mono">order_items</span>, <span class="mono">cart_items</span>
							</td>
						</tr>
						<tr>
							<td>Pydantic schemas</td>
							<td>PascalCase with suffix indicating purpose</td>
							<td>
								<span class="mono">UserCreate</span>, <span class="mono">UserResponse</span>, <span class="mono">ProductUpdate</span>
							</td>
						</tr>
						<tr>
							<td>Repository classes</td>
							<td>PascalCase with "Repository" suffix</td>
							<td>
								<span class="mono">UserRepository</span>, <span class="mono">ProductRepository</span>
							</td>
						</tr>
						<tr>
							<td>Service classes</td>
							<td>PascalCase with "Service" suffix</td>
							<td>
								<span class="mono">UserService</span>, <span class="mono">OrderService</span>
							</td>
						</tr>
						<tr>
							<td>Router variables</td>
							<td>Lowercase module-level variable named <span class="mono">router</span>
							</td>
							<td>
								<span class="mono">router = APIRouter()</span>
							</td>
						</tr>
						<tr>
							<td>Dependency functions</td>
							<td>snake_case, starting with <span class="mono">get_</span> or <span class="mono">require_</span>
							</td>
							<td>
								<span class="mono">get_current_user</span>, <span class="mono">require_admin</span>
							</td>
						</tr>
						<tr>
							<td>Environment variables</td>
							<td>UPPERCASE with underscores</td>
							<td>
								<span class="mono">DATABASE_URL</span>, <span class="mono">SECRET_KEY</span>
							</td>
						</tr>
						<tr>
							<td>Test files</td>
							<td>Prefixed with <span class="mono">test_</span>
							</td>
							<td>
								<span class="mono">test_auth.py</span>, <span class="mono">test_orders.py</span>
							</td>
						</tr>
						<tr>
							<td>Test functions</td>
							<td>Prefixed with <span class="mono">test_</span>, descriptive name</td>
							<td>
								<span class="mono">test_register_duplicate_email_returns_409</span>
							</td>
						</tr>
					</tbody>
				</table>
			</div>
			<div class="callout callout-info">
				<div class="callout-header">üí° Why Structure Matters</div>
				<p>
          A good project structure is not about being fancy ‚Äî it is about <strong>predictability</strong>.
          When you need to fix a bug in product creation, you know to look in
          <span class="mono">services/product.py</span> for business logic,
          <span class="mono">repositories/product.py</span> for database queries,
          <span class="mono">schemas/product.py</span> for validation,
          and <span class="mono">routers/products.py</span> for the endpoint definition.
          Every developer on your team can find things without asking. This predictability
          scales with project size and team size.
        </p>
			</div>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 7 ‚Äî DEVELOPMENT WORKFLOW                             -->
		<!-- =========================================================== -->
		<section id="section-7" class="content-section">
			<div class="section-header">
				<span class="section-number">07</span>
				<h2 class="section-title">Development Workflow</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>How to set up the project from scratch on a new machine</li>
					<li>How to run the application locally during development</li>
					<li>How to run the test suite</li>
					<li>How to add a new feature following a consistent checklist</li>
					<li>How to manage database migrations safely</li>
				</ul>
			</div>
			<h3 id="s7-setup">7.1 Initial Project Setup</h3>
			<p>Follow these steps to set up the project from a fresh clone:</p>
			<ol>
				<li>
					<strong>Clone the repository</strong> and navigate into the project directory.
        </li>
				<li>
					<strong>Create a Python virtual environment.</strong> Use <span class="mono">python -m venv venv</span>
          and activate it. This isolates project dependencies from your system Python.
        </li>
				<li>
					<strong>Install dependencies.</strong> Run <span class="mono">pip install -r requirements.txt</span>.
        </li>
				<li>
					<strong>Copy the environment template.</strong> Copy <span class="mono">.env.example</span>
          to <span class="mono">.env</span> and fill in your local values (database URL, secret key, etc.).
        </li>
				<li>
					<strong>Start infrastructure services.</strong> If using Docker Compose, run the database
          and Redis containers. If using local installations, ensure PostgreSQL and Redis are running.
        </li>
				<li>
					<strong>Create the database.</strong> Create a PostgreSQL database matching the name in your
          <span class="mono">DATABASE_URL</span>.
        </li>
				<li>
					<strong>Run database migrations.</strong> Execute <span class="mono">alembic upgrade head</span>
          to create all tables.
        </li>
				<li>
					<strong>Start the development server.</strong> Run
          <span class="mono">uvicorn app.main:app --reload --host 0.0.0.0 --port 8000</span>.
          The <span class="mono">--reload</span> flag enables auto-restart on code changes.
        </li>
				<li>
					<strong>Verify the setup.</strong> Open <span class="mono">http://localhost:8000/docs</span>
          in your browser. You should see the Swagger UI with the health check endpoint.
        </li>
			</ol>
			<h3 id="s7-running">7.2 Running Locally</h3>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Task</th>
							<th>Command</th>
							<th>Notes</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Start API server (development)</td>
							<td>
								<span class="mono">uvicorn app.main:app --reload</span>
							</td>
							<td>Auto-restarts on code changes</td>
						</tr>
						<tr>
							<td>Start Celery worker</td>
							<td>
								<span class="mono">celery -A app.worker worker --loglevel=info</span>
							</td>
							<td>Run in a separate terminal</td>
						</tr>
						<tr>
							<td>Run all tests</td>
							<td>
								<span class="mono">pytest</span>
							</td>
							<td>Discovers and runs all test files</td>
						</tr>
						<tr>
							<td>Run tests with output</td>
							<td>
								<span class="mono">pytest -v -s</span>
							</td>
							<td>Verbose mode with print output shown</td>
						</tr>
						<tr>
							<td>Run a specific test file</td>
							<td>
								<span class="mono">pytest tests/test_auth.py</span>
							</td>
							<td>Run only authentication tests</td>
						</tr>
						<tr>
							<td>Generate a migration</td>
							<td>
								<span class="mono">alembic revision --autogenerate -m "description"</span>
							</td>
							<td>After modifying models</td>
						</tr>
						<tr>
							<td>Apply migrations</td>
							<td>
								<span class="mono">alembic upgrade head</span>
							</td>
							<td>Applies all pending migrations</td>
						</tr>
						<tr>
							<td>Rollback last migration</td>
							<td>
								<span class="mono">alembic downgrade -1</span>
							</td>
							<td>Undo the most recent migration</td>
						</tr>
						<tr>
							<td>Start everything (Docker)</td>
							<td>
								<span class="mono">docker-compose up --build</span>
							</td>
							<td>Builds images and starts all services</td>
						</tr>
						<tr>
							<td>Stop everything (Docker)</td>
							<td>
								<span class="mono">docker-compose down</span>
							</td>
							<td>Stops and removes containers (data persists in volumes)</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h3 id="s7-new-feature">7.3 Adding a New Feature ‚Äî Checklist</h3>
			<p>
        Every new feature follows the same steps. Use this checklist to ensure consistency:
      </p>
			<ol>
				<li>
					<strong>Define the data model.</strong> Create or modify the SQLAlchemy model in
          <span class="mono">app/models/</span>. Define columns, constraints, and relationships.
        </li>
				<li>
					<strong>Generate a migration.</strong> Run <span class="mono">alembic revision --autogenerate -m "add X table"</span>.
          Review the generated migration file to ensure it matches your expectations. Apply it with
          <span class="mono">alembic upgrade head</span>.
        </li>
				<li>
					<strong>Create Pydantic schemas.</strong> Define request schemas (Create, Update) and
          response schemas in <span class="mono">app/schemas/</span>. Think about which fields are
          required, which are optional, and what validation rules apply.
        </li>
				<li>
					<strong>Build the repository.</strong> Create data access methods in
          <span class="mono">app/repositories/</span>. Keep them generic and reusable. Test with
          simple queries before adding complex ones.
        </li>
				<li>
					<strong>Build the service.</strong> Implement business logic in
          <span class="mono">app/services/</span>. This is where validation rules, ownership checks,
          and multi-step operations live.
        </li>
				<li>
					<strong>Create the dependency.</strong> If needed, add a service factory dependency in
          <span class="mono">app/dependencies/services.py</span>.
        </li>
				<li>
					<strong>Build the router.</strong> Create endpoints in <span class="mono">app/routers/</span>.
          Keep route functions thin ‚Äî parse, call service, return.
        </li>
				<li>
					<strong>Register the router.</strong> Include the new router in
          <span class="mono">app/main.py</span> with the appropriate prefix and tags.
        </li>
				<li>
					<strong>Test manually.</strong> Use Swagger UI at <span class="mono">/docs</span> to verify
          each endpoint works for happy paths and error cases.
        </li>
				<li>
					<strong>Write automated tests.</strong> Add tests in <span class="mono">tests/</span>
          covering the most important flows and edge cases.
        </li>
			</ol>
			<h3 id="s7-migrations">7.4 Database Migration Workflow</h3>
			<p>
        Database migrations deserve special attention because mistakes can cause data loss.
        Follow these practices:
      </p>
			<ul>
				<li>
					<strong>Always review auto-generated migrations.</strong> Alembic's autogeneration is
          helpful but not perfect. It may miss certain changes (like check constraints or index
          renames) or generate unnecessary operations. Read the migration file before applying it.
        </li>
				<li>
					<strong>Use descriptive migration messages.</strong> Instead of "update models", write
          "add orders and order_items tables" or "add is_active column to products". This makes
          the migration history readable.
        </li>
				<li>
					<strong>Never edit an applied migration.</strong> If you made a mistake in a migration
          that has already been applied, create a new migration to fix it. Editing applied migrations
          causes Alembic to lose track of the schema state.
        </li>
				<li>
					<strong>Import all models in <span class="mono">models/__init__.py</span>.</strong>
          Alembic discovers models by importing the Base metadata. If a model is not imported,
          Alembic will not detect it. The <span class="mono">__init__.py</span> in the models
          directory should import all model classes.
        </li>
				<li>
					<strong>Test migrations both ways.</strong> Run <span class="mono">upgrade</span> and
          <span class="mono">downgrade</span> to verify both directions work. This is especially
          important if you ever need to rollback.
        </li>
			</ul>
			<div class="callout callout-warn">
				<div class="callout-header">‚ö†Ô∏è Migration Safety</div>
				<p>
          Be extremely careful with migrations that <strong>drop columns</strong> or
          <strong>change column types</strong>. These operations can cause data loss.
          In a learning project this is not critical, but developing safe migration habits
          now will save you in production. When in doubt, create the migration, review it
          carefully, and test it against a copy of the database before applying to your
          development database.
        </p>
			</div>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 8 ‚Äî SECURITY BASICS                                  -->
		<!-- =========================================================== -->
		<section id="section-8" class="content-section">
			<div class="section-header">
				<span class="section-number">08</span>
				<h2 class="section-title">Security Basics</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>Essential security practices for API development</li>
					<li>Input validation as a security layer</li>
					<li>Password storage best practices</li>
					<li>JWT security considerations</li>
					<li>Rate limiting concepts</li>
					<li>What data to never expose in API responses</li>
				</ul>
			</div>
			<h3 id="s8-validation">8.1 Input Validation as Security</h3>
			<p>
        Input validation is your <strong>first line of defense</strong>. Every piece of data entering
        your API should be validated before it reaches your business logic or database.
      </p>
			<ul>
				<li>
					<strong>Validate types strictly.</strong> Pydantic does this automatically ‚Äî if a field
          expects an integer and receives a string, the request is rejected with a 422 error
          before your code even runs.
        </li>
				<li>
					<strong>Validate ranges and lengths.</strong> Set minimum and maximum values for numbers
          (<span class="mono">ge=1</span>, <span class="mono">le=100</span>), minimum and maximum
          lengths for strings (<span class="mono">min_length=1</span>, <span class="mono">max_length=200</span>),
          and specific patterns for formatted data (email, phone).
        </li>
				<li>
					<strong>Validate business constraints.</strong> Beyond type validation, check that the
          data makes sense in context: prices must be positive, quantities must be non-negative,
          ratings must be 1-5, email addresses must be valid format.
        </li>
				<li>
					<strong>Never trust client input.</strong> Even if the frontend validates data, always
          re-validate on the server. Clients can be bypassed ‚Äî the API is the authoritative
          boundary.
        </li>
				<li>
					<strong>Sanitize file uploads.</strong> Check content type, validate file size, and never
          use the original filename from the client. Generate a new filename server-side.
        </li>
			</ul>
			<h3 id="s8-passwords">8.2 Password Security</h3>
			<ul>
				<li>
					<strong>Never store plain text passwords.</strong> Always hash passwords using bcrypt
          (via the <span class="mono">passlib</span> library). Bcrypt is intentionally slow, making
          brute-force attacks computationally expensive.
        </li>
				<li>
					<strong>Never log passwords.</strong> Do not log request bodies for endpoints that
          accept passwords (registration, login). Do not log password hashes either.
        </li>
				<li>
					<strong>Never return passwords in responses.</strong> Your response schemas should not
          include any password-related fields. Double-check that serialization does not accidentally
          include the <span class="mono">hashed_password</span> column.
        </li>
				<li>
					<strong>Enforce minimum password complexity.</strong> At minimum, require a minimum length
          (8 characters is a reasonable default). You can add more rules (must contain a number,
          uppercase, etc.) but keep it simple for this learning project.
        </li>
				<li>
					<strong>Use generic error messages for login failures.</strong> Return "Invalid credentials"
          for both wrong email and wrong password. Specific messages like "Email not found" help
          attackers enumerate valid accounts.
        </li>
			</ul>
			<h3 id="s8-jwt">8.3 JWT Best Practices</h3>
			<ul>
				<li>
					<strong>Use a strong, random secret key.</strong> Your <span class="mono">SECRET_KEY</span>
          should be at least 32 characters of random data. Generate it with a cryptographic random
          generator, not a human-created string. If the secret is compromised, all tokens become
          forgeable.
        </li>
				<li>
					<strong>Keep access token lifetimes short.</strong> Thirty minutes or less is ideal. Short
          lifetimes limit the damage if a token is stolen. Use refresh tokens for longer sessions.
        </li>
				<li>
					<strong>Differentiate token types.</strong> Include a <span class="mono">type</span> claim
          in the payload ("access" or "refresh"). Validate the type on every endpoint to prevent
          refresh tokens from being used as access tokens and vice versa.
        </li>
				<li>
					<strong>Do not put sensitive data in JWT payloads.</strong> The payload is Base64-encoded,
          not encrypted. Anyone can decode it. Include only the user ID, role, and token metadata.
          Never include passwords, email addresses, or personal information.
        </li>
				<li>
					<strong>Use the <span class="mono">HS256</span> algorithm.</strong> For a single-server
          application, HMAC-based symmetric signing (HS256) is simple and secure. Asymmetric
          algorithms (RS256) are needed for multi-service architectures where different services
          need to verify tokens without knowing the secret.
        </li>
			</ul>
			<h3 id="s8-rate-limiting">8.4 Rate Limiting (Conceptual)</h3>
			<p>
        Rate limiting prevents abuse by restricting how many requests a client can make in a given
        time window. While implementing full rate limiting is beyond this project's scope, understand
        the concept:
      </p>
			<ul>
				<li>
					<strong>Login endpoints</strong> should be rate-limited most aggressively (e.g., 5 attempts
          per minute per IP) to prevent brute-force attacks.
        </li>
				<li>
					<strong>Registration</strong> should also be rate-limited to prevent mass account creation.
        </li>
				<li>
					<strong>General API endpoints</strong> can have a higher limit (e.g., 100 requests per minute).
        </li>
				<li>
          In production, rate limiting is typically implemented using Redis to track request counts
          per client, or handled by an API gateway or reverse proxy (like Nginx) in front of your
          application.
        </li>
			</ul>
			<div class="callout callout-info">
				<div class="callout-header">üí° For This Project</div>
				<p>
          You do not need to implement rate limiting for this learning project. However, if you
          want to explore it, the <span class="mono">slowapi</span> library provides a simple
          rate limiting integration for FastAPI using Redis as the backend.
        </p>
			</div>
			<h3 id="s8-exposure">8.5 What Not to Expose in API Responses</h3>
			<p>
        Carefully control what data your API returns. Over-sharing information is a common
        security mistake:
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Never Expose</th>
							<th>Why</th>
							<th>What to Return Instead</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Password hashes</td>
							<td>Can be cracked offline with specialized tools</td>
							<td>Omit entirely from response schemas</td>
						</tr>
						<tr>
							<td>Internal error stack traces</td>
							<td>Reveal code structure, library versions, file paths</td>
							<td>Generic error message; log the trace server-side</td>
						</tr>
						<tr>
							<td>Other users' email addresses</td>
							<td>Privacy violation; enables phishing</td>
							<td>Display names only in public contexts</td>
						</tr>
						<tr>
							<td>Database auto-increment IDs</td>
							<td>Reveal record counts and can be enumerated sequentially</td>
							<td>Use UUIDs for all public-facing identifiers</td>
						</tr>
						<tr>
							<td>Internal service details</td>
							<td>Reveal infrastructure (database type, cache system, etc.)</td>
							<td>Generic descriptions or omit entirely</td>
						</tr>
						<tr>
							<td>Full SQL error messages</td>
							<td>Reveal table names, column names, query structure</td>
							<td>Generic "database error" message; log details server-side</td>
						</tr>
					</tbody>
				</table>
			</div>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 9 ‚Äî PERFORMANCE BASICS                               -->
		<!-- =========================================================== -->
		<section id="section-9" class="content-section">
			<div class="section-header">
				<span class="section-number">09</span>
				<h2 class="section-title">Performance Basics</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>Database query optimization fundamentals</li>
					<li>When and where to add database indexes</li>
					<li>Why pagination is essential for performance</li>
					<li>Caching patterns and when to apply them</li>
					<li>Connection pooling and why it matters for async applications</li>
				</ul>
			</div>
			<h3 id="s9-queries">9.1 Database Query Optimization Basics</h3>
			<p>
        Database queries are typically the biggest performance bottleneck in web applications.
        Here are the fundamentals:
      </p>
			<ul>
				<li>
					<strong>Select only needed columns.</strong> When you only need a product's name and price,
          do not load all twenty columns. Use SQLAlchemy's <span class="mono">load_only()</span> or
          select specific columns. For list views, you rarely need every field.
        </li>
				<li>
					<strong>Avoid N+1 queries.</strong> This is the most common ORM performance trap. When you
          load a list of products and then access <span class="mono">product.store.name</span> in a
          loop, each access triggers a new database query. Use <span class="mono">selectinload()</span>
          or <span class="mono">joinedload()</span> to eagerly load relationships in the original query.
        </li>
				<li>
					<strong>Use database-level aggregation.</strong> When calculating averages, counts, or sums,
          use SQL aggregate functions rather than loading all rows into Python and computing there. The
          database engine is optimized for these operations and processes them much faster than Python.
        </li>
				<li>
					<strong>Limit result sets.</strong> Never return unbounded results. Always use
          <span class="mono">LIMIT</span> and <span class="mono">OFFSET</span> (pagination) for
          list endpoints. Without limits, a table with millions of rows would crash your API.
        </li>
				<li>
					<strong>Filter in the database, not in Python.</strong> Apply WHERE clauses in your SQL
          queries rather than fetching all rows and filtering in Python. Let the database do the work
          ‚Äî it is designed for this.
        </li>
			</ul>
			<h3 id="s9-indexes">9.2 When to Add Database Indexes</h3>
			<p>
        Indexes speed up read queries at the cost of slightly slower writes and additional storage.
        Add indexes on columns that are frequently used in WHERE clauses, JOIN conditions, or ORDER BY.
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Column</th>
							<th>Table</th>
							<th>Why Index</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<span class="mono">email</span>
							</td>
							<td>users</td>
							<td>Queried on every login. Already unique-constrained (which creates an index).</td>
						</tr>
						<tr>
							<td>
								<span class="mono">owner_id</span>
							</td>
							<td>stores</td>
							<td>Looked up when vendors access their store. Already unique-constrained.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">store_id</span>
							</td>
							<td>products</td>
							<td>Used to filter products by store. Add an explicit index.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">category_id</span>
							</td>
							<td>products</td>
							<td>Used to filter products by category. Add an explicit index.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">slug</span>
							</td>
							<td>categories</td>
							<td>May be used for URL-friendly lookups. Already unique-constrained.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">user_id</span>
							</td>
							<td>orders</td>
							<td>Used to fetch a customer's order history. Add an explicit index.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">order_id</span>
							</td>
							<td>order_items</td>
							<td>Used to load items for a specific order. Add an explicit index.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">store_id</span>
							</td>
							<td>order_items</td>
							<td>Used for vendor order views. Add an explicit index.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">user_id</span>
							</td>
							<td>cart_items</td>
							<td>Queried on every cart operation. Add an explicit index.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">product_id</span>
							</td>
							<td>reviews</td>
							<td>Used to load reviews for a product. Add an explicit index.</td>
						</tr>
						<tr>
							<td>
								<span class="mono">user_id</span>
							</td>
							<td>addresses</td>
							<td>Used to load a user's addresses. Add an explicit index.</td>
						</tr>
					</tbody>
				</table>
			</div>
			<div class="callout callout-info">
				<div class="callout-header">üí° Index Rule of Thumb</div>
				<p>
          Foreign key columns should almost always have an index. Unique constraints automatically
          create indexes. For columns used in WHERE or ORDER BY clauses but without a unique
          constraint, add an explicit index. Do not index columns that are rarely queried or have
          very low selectivity (like boolean flags with only true/false values).
        </p>
			</div>
			<h3 id="s9-pagination">9.3 Pagination Importance</h3>
			<p>
        Pagination is not just a nice-to-have ‚Äî it is a <strong>performance and stability requirement</strong>.
      </p>
			<ul>
				<li>
					<strong>Without pagination:</strong> A query for "all products" on a database with 100,000
          products loads all rows into memory, serializes them to JSON, and sends a multi-megabyte
          response. This is slow, wastes memory, and could crash your server under load.
        </li>
				<li>
					<strong>With pagination:</strong> The same query returns 20 products, takes milliseconds,
          uses minimal memory, and provides a snappy user experience. The client requests more pages
          as needed.
        </li>
				<li>
					<strong>Always set a maximum page size.</strong> Even if the client requests
          <span class="mono">size=10000</span>, cap it at a reasonable maximum (100 is common).
          Validate this in the query parameter definition.
        </li>
				<li>
					<strong>Return total count and page metadata.</strong> Clients need to know how many total
          results exist and how many pages are available to build pagination UI.
        </li>
			</ul>
			<h3 id="s9-caching">9.4 Caching Patterns</h3>
			<p>
        Caching reduces database load by storing frequently-accessed data in a faster data store
        (Redis). Apply caching selectively:
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Data Type</th>
							<th>Cache?</th>
							<th>Reasoning</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Category list</td>
							<td>
								<strong>Yes</strong> ‚Äî long TTL (1 hour)</td>
							<td>Read by almost every product browse. Changes rarely.</td>
						</tr>
						<tr>
							<td>Product detail</td>
							<td>
								<strong>Yes</strong> ‚Äî medium TTL (15 minutes)</td>
							<td>Popular products are viewed frequently. Changes occasionally.</td>
						</tr>
						<tr>
							<td>Store profile</td>
							<td>
								<strong>Yes</strong> ‚Äî medium TTL (15 minutes)</td>
							<td>Read on product detail pages. Changes rarely.</td>
						</tr>
						<tr>
							<td>Product search results</td>
							<td>
								<strong>No</strong>
							</td>
							<td>Too many unique query combinations. Low cache hit rate.</td>
						</tr>
						<tr>
							<td>Shopping cart</td>
							<td>
								<strong>No</strong>
							</td>
							<td>User-specific, changes frequently. Low hit rate per key.</td>
						</tr>
						<tr>
							<td>Order history</td>
							<td>
								<strong>No</strong>
							</td>
							<td>User-specific. Served from indexed database queries efficiently.</td>
						</tr>
						<tr>
							<td>Admin statistics</td>
							<td>
								<strong>Maybe</strong> ‚Äî short TTL (5 minutes)</td>
							<td>Expensive aggregate queries but acceptable to be slightly stale.</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h3 id="s9-pooling">9.5 Connection Pooling</h3>
			<p>
        Opening a database connection is expensive ‚Äî it involves network handshake, authentication,
        and memory allocation. Connection pooling solves this by maintaining a pool of pre-opened
        connections that are reused across requests.
      </p>
			<ul>
				<li>
					<strong>SQLAlchemy handles pooling automatically.</strong> When you create an async engine,
          SQLAlchemy configures a connection pool by default. You can customize the pool size
          (<span class="mono">pool_size</span>), overflow limit (<span class="mono">max_overflow</span>),
          and recycle time (<span class="mono">pool_recycle</span>).
        </li>
				<li>
					<strong>Default pool size is usually 5.</strong> For a learning project, this is fine.
          For production, you would increase it based on your expected concurrency and database
          server capacity.
        </li>
				<li>
					<strong>Always return connections to the pool.</strong> This is why the <span class="mono">get_db</span>
          dependency uses a try/finally block or async context manager ‚Äî to ensure the session (and
          its underlying connection) is returned to the pool even if an exception occurs.
        </li>
				<li>
					<strong>Set <span class="mono">pool_recycle</span>.</strong> Databases close idle
          connections after a timeout. If a pooled connection exceeds this timeout, it becomes stale.
          Setting <span class="mono">pool_recycle</span> to a value less than the database's idle
          timeout (e.g., 3600 seconds) ensures connections are refreshed before they go stale.
        </li>
			</ul>
			<div class="callout callout-warn">
				<div class="callout-header">‚ö†Ô∏è Connection Leaks</div>
				<p>
          If your <span class="mono">get_db</span> dependency does not properly close the session,
          connections are never returned to the pool. Eventually, the pool is exhausted and new
          requests hang waiting for a connection. This is called a connection leak and it is one
          of the most common (and hardest to debug) production issues. Always use
          <span class="mono">try/finally</span> or <span class="mono">async with</span> to
          guarantee cleanup.
        </p>
			</div>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- SECTION 10 ‚Äî DEPLOYMENT BASICS                               -->
		<!-- =========================================================== -->
		<section id="section-10" class="content-section">
			<div class="section-header">
				<span class="section-number">10</span>
				<h2 class="section-title">Deployment Basics</h2>
			</div>
			<div class="callout callout-learn">
				<div class="callout-header">üìñ What You'll Learn in This Section</div>
				<ul>
					<li>How to structure a Dockerfile for FastAPI applications</li>
					<li>How to compose multiple services with Docker Compose</li>
					<li>Environment variable management for different environments</li>
					<li>Health check patterns for containerized services</li>
					<li>Key production considerations beyond this learning project</li>
				</ul>
			</div>
			<h3 id="s10-dockerfile">10.1 Dockerfile Structure</h3>
			<p>
        Your Dockerfile follows a multi-stage build pattern with two stages:
      </p>
			<ol>
				<li>
					<strong>Builder stage:</strong> Uses a full Python image with build tools. Installs all
          Python dependencies into a virtual environment. This stage is not included in the final
          image ‚Äî it exists only to compile dependencies that require C extensions (like
          <span class="mono">asyncpg</span> or <span class="mono">bcrypt</span>).
        </li>
				<li>
					<strong>Production stage:</strong> Uses a slim Python image (much smaller). Copies the
          virtual environment from the builder. Copies the application code. Sets environment
          variables, exposes the port, and defines the startup command. This stage produces the
          final image that you deploy.
        </li>
			</ol>
			<p>Key practices for the Dockerfile:</p>
			<ul>
				<li>
					<strong>Copy <span class="mono">requirements.txt</span> before application code.</strong>
          Docker caches each layer. If your requirements have not changed, Docker reuses the cached
          dependency layer even when your code changes. This makes rebuilds much faster.
        </li>
				<li>
					<strong>Do not run as root.</strong> Create a non-root user in the Dockerfile and switch
          to it before the CMD instruction. Running as root inside a container is a security risk.
        </li>
				<li>
					<strong>Use <span class="mono">.dockerignore</span>.</strong> Exclude files that are not
          needed in the image: <span class="mono">.git</span>, <span class="mono">__pycache__</span>,
          <span class="mono">.env</span>, <span class="mono">tests/</span>,
          <span class="mono">venv/</span>, etc. This reduces build context size and image size.
        </li>
			</ul>
			<h3 id="s10-compose">10.2 Docker Compose Configuration</h3>
			<p>
        Docker Compose defines the complete application stack for local development.
        Your compose file includes four services:
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Service</th>
							<th>Image</th>
							<th>Purpose</th>
							<th>Key Configuration</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<span class="mono">db</span>
							</td>
							<td>postgres:16-alpine</td>
							<td>PostgreSQL database</td>
							<td>Named volume for data persistence, environment variables for database name, user, and password</td>
						</tr>
						<tr>
							<td>
								<span class="mono">redis</span>
							</td>
							<td>redis:7-alpine</td>
							<td>Cache and Celery broker</td>
							<td>Default configuration is usually sufficient</td>
						</tr>
						<tr>
							<td>
								<span class="mono">api</span>
							</td>
							<td>Custom (your Dockerfile)</td>
							<td>FastAPI application</td>
							<td>Port mapping (8000:8000), env_file reference, depends_on db and redis with health checks</td>
						</tr>
						<tr>
							<td>
								<span class="mono">celery-worker</span>
							</td>
							<td>Same as api</td>
							<td>Background task processor</td>
							<td>Different command (celery worker instead of uvicorn), depends_on db and redis</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h3 id="s10-envmanagement">10.3 Environment Variables by Environment</h3>
			<p>
        Different environments need different configuration values. Here is how to organize them:
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Variable</th>
							<th>Development</th>
							<th>Testing</th>
							<th>Production</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<span class="mono">DEBUG</span>
							</td>
							<td>true</td>
							<td>true</td>
							<td>false</td>
						</tr>
						<tr>
							<td>
								<span class="mono">DATABASE_URL</span>
							</td>
							<td>Local or Docker PostgreSQL</td>
							<td>Separate test database</td>
							<td>Managed database service</td>
						</tr>
						<tr>
							<td>
								<span class="mono">SECRET_KEY</span>
							</td>
							<td>Any value (for convenience)</td>
							<td>Any value</td>
							<td>Strong, randomly generated value</td>
						</tr>
						<tr>
							<td>
								<span class="mono">REDIS_URL</span>
							</td>
							<td>Local or Docker Redis</td>
							<td>Separate test Redis (or skip)</td>
							<td>Managed Redis service</td>
						</tr>
						<tr>
							<td>
								<span class="mono">ALLOWED_ORIGINS</span>
							</td>
							<td>["*"] (all origins)</td>
							<td>["*"]</td>
							<td>["https://yourdomain.com"]</td>
						</tr>
						<tr>
							<td>
								<span class="mono">ACCESS_TOKEN_EXPIRE_MINUTES</span>
							</td>
							<td>60 (longer for convenience)</td>
							<td>5 (short for testing expiry)</td>
							<td>30</td>
						</tr>
					</tbody>
				</table>
			</div>
			<h3 id="s10-health">10.4 Health Check Patterns</h3>
			<p>
        Health checks tell the infrastructure (Docker, Kubernetes, load balancers) whether your
        application is ready to receive traffic. Your health check endpoint should verify:
      </p>
			<ol>
				<li>
					<strong>Database connectivity.</strong> Execute a simple query (like
          <span class="mono">SELECT 1</span>) to verify the database connection is alive.
        </li>
				<li>
					<strong>Redis connectivity.</strong> Send a <span class="mono">PING</span> command to Redis
          and verify it responds with <span class="mono">PONG</span>.
        </li>
				<li>
					<strong>Application readiness.</strong> The fact that the endpoint responds at all means the
          FastAPI server is running.
        </li>
			</ol>
			<p>
        Return a JSON object with the status of each dependency. If any critical dependency is
        down, return a 503 Service Unavailable status instead of 200. This allows monitoring
        systems to detect problems automatically.
      </p>
			<div class="callout callout-info">
				<div class="callout-header">üí° Health Check Response Structure</div>
				<p>
          A good health check response includes: overall <span class="mono">status</span>
          ("healthy" or "unhealthy"), individual dependency statuses
          (<span class="mono">database</span>: "connected", <span class="mono">redis</span>: "connected"),
          and a <span class="mono">timestamp</span>. Some systems also include the application
          version for operational visibility.
        </p>
			</div>
			<h3 id="s10-production">10.5 Production Considerations</h3>
			<p>
        This section lists things you would need for a real production deployment. You do not need
        to implement these for this learning project, but being aware of them makes you a more
        well-rounded developer.
      </p>
			<div class="table-wrap">
				<table>
					<thead>
						<tr>
							<th>Concern</th>
							<th>Development (This Project)</th>
							<th>Production (Real World)</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>HTTPS/SSL</td>
							<td>Not needed (HTTP on localhost)</td>
							<td>Required. Terminate SSL at Nginx/load balancer level.</td>
						</tr>
						<tr>
							<td>Server Workers</td>
							<td>Single Uvicorn process</td>
							<td>Gunicorn with multiple Uvicorn workers for concurrency.</td>
						</tr>
						<tr>
							<td>Database</td>
							<td>Docker PostgreSQL container</td>
							<td>Managed service (RDS, Cloud SQL) with automated backups.</td>
						</tr>
						<tr>
							<td>File Storage</td>
							<td>Local filesystem</td>
							<td>Object storage (S3, GCS) with CDN for serving.</td>
						</tr>
						<tr>
							<td>Logging</td>
							<td>Console output</td>
							<td>Structured JSON logs shipped to a log aggregator (ELK, Datadog).</td>
						</tr>
						<tr>
							<td>Monitoring</td>
							<td>Manual checking</td>
							<td>APM tools (Sentry, New Relic), uptime monitoring, alerting.</td>
						</tr>
						<tr>
							<td>CI/CD</td>
							<td>Manual deployment</td>
							<td>Automated pipeline: test ‚Üí build image ‚Üí deploy to staging ‚Üí deploy to production.</td>
						</tr>
						<tr>
							<td>Secrets Management</td>
							<td>
								<span class="mono">.env</span> file</td>
							<td>Secrets manager (AWS Secrets Manager, Vault, Kubernetes Secrets).</td>
						</tr>
						<tr>
							<td>Rate Limiting</td>
							<td>None</td>
							<td>API gateway or middleware-based rate limiting per client/IP.</td>
						</tr>
						<tr>
							<td>Backups</td>
							<td>None</td>
							<td>Automated database backups with point-in-time recovery.</td>
						</tr>
					</tbody>
				</table>
			</div>
			<div class="callout callout-info">
				<div class="callout-header">üí° Your Learning Path Forward</div>
				<p>
          Completing this project gives you a solid foundation in FastAPI and backend API
          development. The natural next steps for continued learning would be:
        </p>
				<ul>
					<li>
						<strong>Add CI/CD</strong> using GitHub Actions to automatically run tests on every push</li>
					<li>
						<strong>Deploy to a cloud platform</strong> like Fly.io, Railway, or AWS ECS</li>
					<li>
						<strong>Add a frontend</strong> using React, Vue, or even simple HTML/JavaScript to consume your API</li>
					<li>
						<strong>Implement additional features</strong> from the optional extensions list (wishlists, coupons, notifications)</li>
					<li>
						<strong>Explore async patterns</strong> more deeply ‚Äî concurrent external API calls, streaming responses</li>
					<li>
						<strong>Learn about API versioning</strong> strategies for evolving your API without breaking existing clients</li>
				</ul>
			</div>
		</section>
		<hr class="section-divider"/>
		<!-- =========================================================== -->
		<!-- FINAL SECTION ‚Äî CLOSING                                      -->
		<!-- =========================================================== -->
		<section class="content-section closing-section">
			<div class="closing-content">
				<h2>üéâ You Have the Complete Blueprint</h2>
				<p>
          This document contains everything you need to build a multi-vendor marketplace API with
          FastAPI from scratch. You have the database schema, every API endpoint, a detailed
          phase-by-phase guide, and the supporting knowledge on security, performance, and deployment.
        </p>
				<p>
          Remember the core principles:
        </p>
				<ul>
					<li>
						<strong>Follow the layered architecture</strong> ‚Äî Router ‚Üí Service ‚Üí Repository ‚Üí Model</li>
					<li>
						<strong>Use dependency injection</strong> ‚Äî it is FastAPI's superpower</li>
					<li>
						<strong>Complete phases in order</strong> ‚Äî each builds on the previous</li>
					<li>
						<strong>Understand the "why"</strong> ‚Äî patterns matter more than syntax</li>
					<li>
						<strong>Test your work</strong> ‚Äî verify each phase before moving forward</li>
					<li>
						<strong>Keep it simple</strong> ‚Äî this is for learning, not production</li>
				</ul>
				<p class="closing-cta">
          Open Phase 1, set up your project, and start building. Good luck! üöÄ
        </p>
			</div>
		</section>
		<!-- ==================== BACK TO TOP ==================== -->
		<button id="back-to-top" class="back-to-top" aria-label="Back to top" title="Back to top">‚Üë</button>
	</main>
	<!-- end main-content -->
	<script src="script.min.js" defer></script>
</body>
</html>



